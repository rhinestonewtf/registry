{"language":"Solidity","sources":{"src/Registry.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.24;\n\nimport { SignedAttestation } from \"./core/SignedAttestation.sol\";\nimport { IRegistry } from \"./IRegistry.sol\";\n\n/**\n * ## Overview\n *\n * Account abstraction (or smart accounts) will deliver three key enhancements for the Ethereum ecosystem:\n * improved UX, enhanced user security and greater wallet extensibility. Modular smart accounts are the next\n * frontier for achieving these goals. However, it also opens up a number of new challenges that\n * could drastically undermine the objective by opening up a plethora of new attack vectors and security concerns for accounts.\n *\n * The Registry aims to solve this concern by providing a means of verifying the legitimacy and\n * security of independently built smart account modules for installation and use across any integrated\n * smart account. It allows entities to attest to statements about modules and smart accounts to query these\n *  at module installation and/or execution time. The Registry is a Singleton that is free, open and\n *  permissionless. It also serves as the reference implementation\n *  for [ERC-7484](https://eips.ethereum.org/EIPS/eip-7484).\n * ## Core Concepts\n * ### Attestations\n * Attestations on the Registry represent statements about Modules. An Attestation is made using a\n *  particular [Schema](./Schemas.md) that is used to encode and decode the Attestation data. The\n *  most important usecase for Attestations is to make statements about the security of a Module.\n *\n * An attestation consists of two primary elements: the Schema and the\n * Attestation data. The Schema acts as a standardized structure for\n * creating and validating Attestations, defining how the Attestation data is encoded and decoded.\n *\n * ### Schemas\n *\n * [Schemas](./docs/Schema.md) represent predefined structures utilized for the formation and\n * verification of Attestation data. Using flexible Schemas rather than a single, fixed Schema\n * allows Attesters to encode their data in a custom way, providing flexibility when creating\n * Attestations. For example, the data of an Attestation about the outcome of the formal\n * verification on a Module will have a very format than the data of an Attestation about what\n * interfaces a Module supports.\n *\n * ### Resolvers\n *\n * Resolvers are external contracts that are tied to Modules and called when specific Registry actions are executed. These actions are:\n * - attestation\n * - revocation\n * - module registration / deployment\n *\n * This architectural design aims to provide entities like Smart Account vendors or DAOs, with the\n * flexibility to incorporate custom business logic while maintaining the\n * robustness and security of the core functionalities implemented by the Registry\n *\n * ### Attesters\n * Attesters are individuals or organizations responsible for\n * creating and signing Attestations. They add the Attestation to the\n * Registry, making it available for verification.\n *\n * ### Modules\n * Modules are smart contracts that act as modular components that can be added to Smart Accounts.\n * The registry is agnostic towards Smart Account or Module implementations. Only Module addresses and\n * deployment metadata are stored on the registry.\n *\n * Modules are registered on the Registry either during, using `CREATE2`, `CREATE3`\n *  or a custom deployment factory, or after deployment.\n *\n * ## Architecture\n *\n * ![Sequence Diagram](https://raw.githubusercontent.com/rhinestonewtf/registry/main/public/docs/all.svg)\n *\n * Implementation of all features of the registry:\n *      - Register Schemas\n *      - Register External Resolvers\n *      - Register Modules\n *      - Make Attestations\n *      - Make Revocations\n *      - Delegate Trust to Attester(s)\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\n */\ncontract Registry is IRegistry, SignedAttestation { }\n"},"src/core/SignedAttestation.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.24;\n\nimport { Attestation } from \"./Attestation.sol\";\nimport { AttestationRequest, RevocationRequest, SchemaUID } from \"../DataTypes.sol\";\nimport { AttestationLib } from \"../lib/AttestationLib.sol\";\nimport { EIP712 } from \"solady/utils/EIP712.sol\";\nimport { SignatureCheckerLib } from \"solady/utils/SignatureCheckerLib.sol\";\nimport { IRegistry } from \"../IRegistry.sol\";\n\n/**\n * Implements similar functionality to Attestation.sol, but with the added feature of requiring a signature from the attester.\n *\n * ## Signed Attestations\n *\n * All Attestations leveraged within the Registry are designated as \"signed/delegated\".\n * Such Attestations empower an entity to sign an attestation while enabling another entity to\n * bear the transaction cost. With these attestations, the actual Attester and the one relaying the\n * Attestation can be separate entities, thus accommodating a variety of use cases.\n * This becomes particularly beneficial when:\n * Signatures may be provided as `ECDSA` or `ERC-1271`\n *\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\n */\ncontract SignedAttestation is IRegistry, Attestation, EIP712 {\n    using AttestationLib for AttestationRequest;\n    using AttestationLib for RevocationRequest;\n    using AttestationLib for AttestationRequest[];\n    using AttestationLib for RevocationRequest[];\n\n    mapping(address attester => uint256 nonce) public attesterNonce;\n\n    /**\n     * @inheritdoc IRegistry\n     */\n    function attest(SchemaUID schemaUID, address attester, AttestationRequest calldata request, bytes calldata signature) external {\n        uint256 nonce = ++attesterNonce[attester];\n        bytes32 digest = _hashTypedData(request.hash(nonce));\n        bool valid = SignatureCheckerLib.isValidSignatureNow(attester, digest, signature);\n        if (!valid) revert InvalidSignature();\n\n        _attest({ attester: attester, schemaUID: schemaUID, request: request });\n    }\n\n    /**\n     * @inheritdoc IRegistry\n     */\n    function attest(SchemaUID schemaUID, address attester, AttestationRequest[] calldata requests, bytes calldata signature) external {\n        uint256 nonce = ++attesterNonce[attester];\n        bytes32 digest = _hashTypedData(requests.hash(nonce));\n        bool valid = SignatureCheckerLib.isValidSignatureNow(attester, digest, signature);\n        if (!valid) revert InvalidSignature();\n\n        _attest({ attester: attester, schemaUID: schemaUID, requests: requests });\n    }\n\n    /**\n     * @inheritdoc IRegistry\n     */\n    function revoke(address attester, RevocationRequest calldata request, bytes calldata signature) external {\n        uint256 nonce = ++attesterNonce[attester];\n        bytes32 digest = _hashTypedData(request.hash(nonce));\n        bool valid = SignatureCheckerLib.isValidSignatureNow(attester, digest, signature);\n        if (!valid) revert InvalidSignature();\n\n        _revoke({ attester: attester, request: request });\n    }\n\n    /**\n     * @inheritdoc IRegistry\n     */\n    function revoke(address attester, RevocationRequest[] calldata requests, bytes calldata signature) external {\n        uint256 nonce = ++attesterNonce[attester];\n        bytes32 digest = _hashTypedData(requests.hash(nonce));\n        bool valid = SignatureCheckerLib.isValidSignatureNow(attester, digest, signature);\n        if (!valid) revert InvalidSignature();\n\n        _revoke({ attester: attester, requests: requests });\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  EIP712 Digest Helpers                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * override thats used by Solady's EIP712 cache (constructor)\n     */\n    function _domainNameAndVersion() internal view virtual override returns (string memory name, string memory version) {\n        name = \"RhinestoneRegistry\";\n        version = \"v1.0\";\n    }\n\n    function getDigest(AttestationRequest calldata request, address attester) external view returns (bytes32 digest) {\n        digest = _hashTypedData(request.hash(attesterNonce[attester] + 1));\n    }\n\n    function getDigest(AttestationRequest[] calldata requests, address attester) external view returns (bytes32 digest) {\n        digest = _hashTypedData(requests.hash(attesterNonce[attester] + 1));\n    }\n\n    function getDigest(RevocationRequest calldata request, address attester) external view returns (bytes32 digest) {\n        digest = _hashTypedData(request.hash(attesterNonce[attester] + 1));\n    }\n\n    function getDigest(RevocationRequest[] calldata requests, address attester) external view returns (bytes32 digest) {\n        digest = _hashTypedData(requests.hash(attesterNonce[attester] + 1));\n    }\n}\n"},"src/IRegistry.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.24;\n\nimport {\n    AttestationDataRef,\n    AttestationRecord,\n    AttestationRequest,\n    ModuleType,\n    ModuleRecord,\n    ResolverUID,\n    ResolverRecord,\n    RevocationRequest,\n    SchemaUID,\n    SchemaRecord\n} from \"./DataTypes.sol\";\nimport { IExternalSchemaValidator } from \"./external/IExternalSchemaValidator.sol\";\nimport { IExternalResolver } from \"./external/IExternalResolver.sol\";\nimport { IERC7484 } from \"./interfaces/IERC7484.sol\";\n\n/**\n * Interface definition of all features of the registry:\n *      - Register Schemas\n *      - Register External Resolvers\n *      - Register Modules\n *      - Make Attestations\n *      - Make Revocations\n *      - Delegate Trust to Attester(s)\n *\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\n */\ninterface IRegistry is IERC7484 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*             Smart Account - Trust Management               */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    error InvalidResolver(IExternalResolver resolver);\n    error InvalidResolverUID(ResolverUID uid);\n    error InvalidTrustedAttesterInput();\n    error NoTrustedAttestersFound();\n    error RevokedAttestation(address attester);\n    error InvalidModuleType();\n    error AttestationNotFound();\n\n    error InsufficientAttestations();\n\n    /**\n     * Get trusted attester for a specific Smart Account\n     * @param smartAccount The address of the Smart Account\n     */\n    function findTrustedAttesters(address smartAccount) external view returns (address[] memory attesters);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       Attestations                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    event Revoked(address indexed moduleAddress, address indexed revoker, SchemaUID schema);\n    event Attested(address indexed moduleAddress, address indexed attester, SchemaUID schemaUID, AttestationDataRef indexed sstore2Pointer);\n\n    error AlreadyRevoked();\n    error AlreadyAttested();\n    error ModuleNotFoundInRegistry(address module);\n    error AccessDenied();\n    error InvalidAttestation();\n    error InvalidExpirationTime();\n    error DifferentResolvers();\n    error InvalidSignature();\n    error InvalidModuleTypes();\n\n    /**\n     * Allows `msg.sender` to attest to multiple modules' security status.\n     * The `AttestationRequest.Data` provided should match the attestation\n     * schema defined by the Schema corresponding to the SchemaUID\n     *\n     * @dev This function will revert if the same module is attested twice by the same attester.\n     *      If you want to re-attest, you have to revoke your attestation first, and then attest again.\n     *\n     * @param schemaUID The SchemaUID of the schema the attestation is based on.\n     * @param request a single AttestationRequest\n     */\n    function attest(SchemaUID schemaUID, AttestationRequest calldata request) external;\n\n    /**\n     * Allows `msg.sender` to attest to multiple modules' security status.\n     * The `AttestationRequest.Data` provided should match the attestation\n     * schema defined by the Schema corresponding to the SchemaUID\n     *\n     * @dev This function will revert if the same module is attested twice by the same attester.\n     *      If you want to re-attest, you have to revoke your attestation first, and then attest again.\n     *\n     * @param schemaUID The SchemaUID of the schema the attestation is based on.\n     * @param requests An array of AttestationRequest\n     */\n    function attest(SchemaUID schemaUID, AttestationRequest[] calldata requests) external;\n\n    /**\n     * Allows attester to attest by signing an `AttestationRequest` (`ECDSA` or `ERC1271`)\n     * The `AttestationRequest.Data` provided should match the attestation\n     * schema defined by the Schema corresponding to the SchemaUID\n     *\n     * @dev This function will revert if the same module is attested twice by the same attester.\n     *      If you want to re-attest, you have to revoke your attestation first, and then attest again.\n     *\n     * @param schemaUID The SchemaUID of the schema the attestation is based on.\n     * @param attester The address of the attester\n     * @param request An AttestationRequest\n     * @param signature The signature of the attester. ECDSA or ERC1271\n     */\n    function attest(SchemaUID schemaUID, address attester, AttestationRequest calldata request, bytes calldata signature) external;\n\n    /**\n     * Allows attester to attest by signing an `AttestationRequest` (`ECDSA` or `ERC1271`)\n     * The `AttestationRequest.Data` provided should match the attestation\n     * schema defined by the Schema corresponding to the SchemaUID\n     *\n     * @dev This function will revert if the same module is attested twice by the same attester.\n     *      If you want to re-attest, you have to revoke your attestation first, and then attest again.\n     *\n     * @param schemaUID The SchemaUID of the schema the attestation is based on.\n     * @param attester The address of the attester\n     * @param requests An array of AttestationRequest\n     * @param signature The signature of the attester. ECDSA or ERC1271\n     */\n    function attest(SchemaUID schemaUID, address attester, AttestationRequest[] calldata requests, bytes calldata signature) external;\n\n    /**\n     * Getter function to get AttestationRequest made by one attester\n     */\n    function findAttestation(address module, address attester) external view returns (AttestationRecord memory attestation);\n\n    /**\n     * Getter function to get AttestationRequest made by multiple attesters\n     */\n    function findAttestations(\n        address module,\n        address[] calldata attesters\n    )\n        external\n        view\n        returns (AttestationRecord[] memory attestations);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       Revocations                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * Allows `msg.sender` to revoke an attestation made by the same `msg.sender`\n     *\n     * @dev this function will revert if the attestation is not found\n     * @dev this function will revert if the attestation is already revoked\n     *\n     * @param request single RevocationRequest\n     */\n    function revoke(RevocationRequest calldata request) external;\n\n    /**\n     * Allows msg.sender to revoke multiple attestation made by the same msg.sender\n     *\n     * @dev this function will revert if the attestation is not found\n     * @dev this function will revert if the attestation is already revoked\n     *\n     * @param requests the RevocationRequests\n     */\n    function revoke(RevocationRequest[] calldata requests) external;\n\n    /**\n     * Allows attester to revoke an attestation by signing an `RevocationRequest` (`ECDSA` or `ERC1271`)\n     *\n     * @param attester the signer / revoker\n     * @param request single RevocationRequest\n     * @param signature ECDSA or ERC1271 signature\n     */\n    function revoke(address attester, RevocationRequest calldata request, bytes calldata signature) external;\n\n    /**\n     * Allows attester to revoke an attestation by signing an `RevocationRequest` (`ECDSA` or `ERC1271`)\n     * @dev if you want to revoke multiple attestations, but from different attesters, call this function multiple times\n     *\n     * @param attester the signer / revoker\n     * @param requests array of RevocationRequests\n     * @param signature ECDSA or ERC1271 signature\n     */\n    function revoke(address attester, RevocationRequest[] calldata requests, bytes calldata signature) external;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    Module Registration                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n    // Event triggered when a module is deployed.\n    event ModuleRegistration(address indexed implementation);\n\n    error AlreadyRegistered(address module);\n    error InvalidDeployment();\n    error ModuleAddressIsNotContract(address moduleAddress);\n    error FactoryCallFailed(address factory);\n\n    /**\n     * Module Developers can deploy their module Bytecode directly via the registry.\n     * This registry implements a `CREATE2` factory, that allows module developers to register and deploy module bytecode\n     * @param salt The salt to be used in the `CREATE2` factory. This adheres to Pr000xy/Create2Factory.sol salt formatting.\n     *             The salt's first bytes20 should be the address of the sender\n     *             or bytes20(0) to bypass the check (this will lose replay protection)\n     * @param resolverUID The resolverUID to be used in the `CREATE2` factory\n     * @param initCode The initCode to be used in the `CREATE2` factory\n     * @param metadata The metadata to be stored on the registry.\n     *            This field is optional, and might be used by the module developer to store additional\n     *            information about the module or facilitate business logic with the Resolver stub\n     * @param resolverContext bytes that will be passed to the resolver contract\n     */\n    function deployModule(\n        bytes32 salt,\n        ResolverUID resolverUID,\n        bytes calldata initCode,\n        bytes calldata metadata,\n        bytes calldata resolverContext\n    )\n        external\n        payable\n        returns (address moduleAddress);\n\n    /**\n     * In order to make the integration into existing business logics possible,\n     * the Registry is able to utilize external factories that can be utilized to deploy the modules.\n     * @dev Registry can use other factories to deploy the module.\n     * @dev Note that this function will call the external factory via the FactoryTrampoline contract.\n     *           Factory MUST not assume that msg.sender == registry\n     * @dev This function is used to deploy and register a module using a factory contract.\n     *           Since one of the parameters of this function is a unique resolverUID and any\n     *           registered module address can only be registered once,\n     *           using this function is of risk for a frontrun attack\n     */\n    function deployViaFactory(\n        address factory,\n        bytes calldata callOnFactory,\n        bytes calldata metadata,\n        ResolverUID resolverUID,\n        bytes calldata resolverContext\n    )\n        external\n        payable\n        returns (address moduleAddress);\n\n    /**\n     * Already deployed module addresses can be registered on the registry\n     * @dev This function is used to deploy and register an already deployed module.\n     *           Since one of the parameters of this function is a unique resolverUID and any\n     *           registered module address can only be registered once,\n     *           using this function is of risk for a frontrun attack\n     * @dev the sender address of this registration is set to address(0) since anyone can invoke this function\n     * @param resolverUID The resolverUID to be used for the module\n     * @param moduleAddress The address of the module to be registered\n     * @param metadata The metadata to be stored on the registry.\n     *            This field is optional, and might be used by the module developer to store additional\n     *            information about the module or facilitate business logic with the Resolver stub\n     * @param resolverContext bytes that will be passed to the resolver contract\n     */\n    function registerModule(\n        ResolverUID resolverUID,\n        address moduleAddress,\n        bytes calldata metadata,\n        bytes calldata resolverContext\n    )\n        external;\n\n    /**\n     * in conjunction with the deployModule() function, this function let's you\n     * predict the address of a CREATE2 module deployment\n     * @param salt CREATE2 salt\n     * @param initCode module initcode\n     * @return moduleAddress counterfactual address of the module deployment\n     */\n    function calcModuleAddress(bytes32 salt, bytes calldata initCode) external view returns (address);\n\n    /**\n     * Getter function to get the stored ModuleRecord for a specific module address.\n     * @param moduleAddress The address of the module\n     */\n    function findModule(address moduleAddress) external view returns (ModuleRecord memory moduleRecord);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      Manage Schemas                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    event SchemaRegistered(SchemaUID indexed uid, address indexed registerer);\n\n    error SchemaAlreadyExists(SchemaUID uid);\n\n    error InvalidSchema();\n    error InvalidSchemaValidator(IExternalSchemaValidator validator);\n\n    /**\n     * Register Schema and (optional) external `IExternalSchemaValidator`\n     * A Schema describe the structure of the data of attestations\n     * every attestation made on this registry, will reference a SchemaUID to\n     *  make it possible to decode attestation data in human readable form\n     * overwriting a schema is not allowed, and will revert\n     * @param schema ABI schema used to encode attestations that are made with this schema\n     * @param validator (optional) external schema validator that will be used to validate attestations.\n     *                  use address(0), if you don't need an external validator\n     * @return uid SchemaUID of the registered schema\n     */\n    function registerSchema(\n        string calldata schema,\n        IExternalSchemaValidator validator // OPTIONAL\n    )\n        external\n        returns (SchemaUID uid);\n\n    /**\n     * Getter function to retrieve SchemaRecord\n     */\n    function findSchema(SchemaUID uid) external view returns (SchemaRecord memory record);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     Manage Resolvers                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    event NewResolver(ResolverUID indexed uid, address indexed resolver);\n    event NewResolverOwner(ResolverUID indexed uid, address newOwner);\n\n    error ResolverAlreadyExists();\n\n    /**\n     * Allows Marketplace Agents to register external resolvers.\n     * @param  resolver external resolver contract\n     * @return uid ResolverUID of the registered resolver\n     */\n    function registerResolver(IExternalResolver resolver) external returns (ResolverUID uid);\n\n    /**\n     * Entities that previously registered an external resolver, may update the implementation address.\n     * @param uid The UID of the resolver.\n     * @param resolver The new resolver implementation address.\n     */\n    function setResolver(ResolverUID uid, IExternalResolver resolver) external;\n\n    /**\n     * Transfer ownership of resolverUID to a new address\n     * @param uid The UID of the resolver to transfer ownership for\n     * @param newOwner The address of the new owner\n     */\n    function transferResolverOwnership(ResolverUID uid, address newOwner) external;\n\n    /**\n     * Getter function to get the ResolverRecord of a registered resolver\n     * @param uid The UID of the resolver.\n     */\n    function findResolver(ResolverUID uid) external view returns (ResolverRecord memory record);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       Stub Errors                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    error ExternalError_SchemaValidation();\n    error ExternalError_ResolveAttestation();\n    error ExternalError_ResolveRevocation();\n    error ExternalError_ModuleRegistration();\n}\n"},"src/core/Attestation.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.24;\n\nimport { AttestationRecord, AttestationRequest, RevocationRequest, SchemaUID } from \"../DataTypes.sol\";\nimport { AttestationManager } from \"./AttestationManager.sol\";\nimport { IRegistry } from \"../IRegistry.sol\";\n\n/**\n *  Abstract contract that implements the `IRegistry` interface\n *\n *  Attestations on the Registry represent statements about Modules.\n *  An Attestation is made using a particular Schema that is used to encode and decode the Attestation data.\n *  The most important usecase for Attestations is to make statements about the security of a Module.\n *\n * ## Attestation Lifecycle\n *\n *  When an Attester creates an Attestation, the Attestation data, structured according to the Schema provided\n *  by the Attester, is then added to the Registry. During the Attestation's lifecycle, the Registry can invoke\n *  hooks on the SchemaResolver during specific events like Attestation creation and revocation.\n *  This allows the SchemaResolver to ensure the integrity and correctness of the attestation throughout\n *  its lifecycle.\n *\n *  ### AttestationRequest\n *  data is `abi.encode()` according to a defined schema. The data is not stored in the storage of the Registry,\n *  but is rather stored with `SSTORE2` to save gas and a pointer to this data is stored on the Registry.\n *\n * ![Sequence Diagram](public/docs/attestationOnly.svg)\n *\n * ### Interactions with the SchemaValidator\n *\n * Attestation data can be validated with an external contract than may to `abi.decode()` and validate all or specific fields.\n *\n * ### Interaction with the IExternalResolver\n *\n * Upon an Attestation's revocation, the Registry calls hooks on the associated IResolver, allowing the IResolver to\n * update its internal state or\n * perform other necessary actions. This allows for extended business logic integrations.\n *\n * ### The Revocation Process\n *\n * In the event that an Attester decides to revoke an Attestation, they issue a revocation call to the Registry.\n *  Upon receiving this call, the registry updates the revocationTime field within the attestation record.\n *  This timestamp acts as a clear indication that the attestation has been revoked, and any trust or claims\n *  that stem from it should be reconsidered.\n *\n * It's important to note that apart from the revocationTime, the rest of the attestation's metadata and data\n *  remains unchanged.\n * Due to the nature of `SSTORE2`, all attestation data will remain onchain and thus preserves the history of\n *  attestations done.\n *\n * ### Editing Attestations\n *\n * Attestations can not be edited. Should attestation data change, the old attestation must be revoked and a new attestation issued.\n *\n *\n * - A service opts to cover its users' Attestation costs (taking care of gas expenses)\n * - An entity wishes to execute multiple Attestations but allows the recipient or a different party to\n *  handle the transaction fees for blockchain integration.\n * Allows `msg.sender` to make attestations / revocations directly\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\n */\nabstract contract Attestation is IRegistry, AttestationManager {\n    /**\n     * @inheritdoc IRegistry\n     */\n    function attest(SchemaUID schemaUID, AttestationRequest calldata request) external {\n        _attest(msg.sender, schemaUID, request);\n    }\n\n    /**\n     * @inheritdoc IRegistry\n     */\n    function attest(SchemaUID schemaUID, AttestationRequest[] calldata requests) external {\n        _attest(msg.sender, schemaUID, requests);\n    }\n\n    /**\n     * @inheritdoc IRegistry\n     */\n    function revoke(RevocationRequest calldata request) external {\n        _revoke(msg.sender, request);\n    }\n\n    /**\n     * @inheritdoc IRegistry\n     */\n    function revoke(RevocationRequest[] calldata requests) external {\n        _revoke(msg.sender, requests);\n    }\n\n    /**\n     * @inheritdoc IRegistry\n     */\n    function findAttestation(address module, address attester) external view returns (AttestationRecord memory attestation) {\n        attestation = $getAttestation(module, attester);\n    }\n\n    /**\n     * @inheritdoc IRegistry\n     */\n    function findAttestations(\n        address module,\n        address[] calldata attesters\n    )\n        external\n        view\n        returns (AttestationRecord[] memory attestations)\n    {\n        uint256 length = attesters.length;\n        attestations = new AttestationRecord[](length);\n        for (uint256 i; i < length; i++) {\n            attestations[i] = $getAttestation(module, attesters[i]);\n        }\n    }\n}\n"},"src/DataTypes.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.24;\n\nimport { IExternalSchemaValidator } from \"./external/IExternalSchemaValidator.sol\";\nimport { IExternalResolver } from \"./external/IExternalResolver.sol\";\n\n/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n/*                     Storage Structs                        */\n/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\nstruct AttestationRecord {\n    uint48 time; // The time when the attestation was created (Unix timestamp).\n    uint48 expirationTime; // The time when the attestation expires (Unix timestamp).\n    uint48 revocationTime; // The time when the attestation was revoked (Unix timestamp).\n    PackedModuleTypes moduleTypes; // bit-wise encoded module types. See ModuleTypeLib\n    address moduleAddress; // The implementation address of the module that is being attested.\n    address attester; // The attesting account.\n    AttestationDataRef dataPointer; // SSTORE2 pointer to the attestation data.\n    SchemaUID schemaUID; // The unique identifier of the schema.\n}\n\nstruct ModuleRecord {\n    ResolverUID resolverUID; // The unique identifier of the resolver.\n    address sender; // The address of the sender who deployed the contract\n    bytes metadata; // Additional data related to the contract deployment\n}\n\nstruct SchemaRecord {\n    uint48 registeredAt; // The time when the schema was registered (Unix timestamp).\n    IExternalSchemaValidator validator; // Optional external schema validator.\n    string schema; // Custom specification of the schema (e.g., an ABI).\n}\n\nstruct ResolverRecord {\n    IExternalResolver resolver; // Optional resolver.\n    address resolverOwner; // The address of the account used to register the resolver.\n}\n\n// Struct that represents a trusted attester.\nstruct TrustedAttesterRecord {\n    uint8 attesterCount; // number of attesters in the linked list\n    uint8 threshold; // minimum number of attesters required\n    address attester; // first attester in linked list. (packed to save gas)\n    mapping(address attester => mapping(address account => address linkedAttester)) linkedAttesters;\n}\n\n/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n/*            Attestation / Revocation Requests               */\n/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n/**\n * @dev A struct representing the arguments of the attestation request.\n */\nstruct AttestationRequest {\n    address moduleAddress; // The moduleAddress of the attestation.\n    uint48 expirationTime; // The time when the attestation expires (Unix timestamp).\n    bytes data; // Custom attestation data.\n    ModuleType[] moduleTypes; // optional: The type(s) of the module.\n}\n\n/**\n * @dev A struct representing the arguments of the revocation request.\n */\nstruct RevocationRequest {\n    address moduleAddress; // The module address.\n}\n\n/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n/*                       Custom Types                         */\n/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n//---------------------- SchemaUID ------------------------------|\ntype SchemaUID is bytes32;\n\nusing { schemaEq as == } for SchemaUID global;\nusing { schemaNotEq as != } for SchemaUID global;\n\nfunction schemaEq(SchemaUID uid1, SchemaUID uid2) pure returns (bool) {\n    return SchemaUID.unwrap(uid1) == SchemaUID.unwrap(uid2);\n}\n\nfunction schemaNotEq(SchemaUID uid1, SchemaUID uid2) pure returns (bool) {\n    return SchemaUID.unwrap(uid1) != SchemaUID.unwrap(uid2);\n}\n\n//--------------------- ResolverUID -----------------------------|\ntype ResolverUID is bytes32;\n\nusing { resolverEq as == } for ResolverUID global;\nusing { resolverNotEq as != } for ResolverUID global;\n\nfunction resolverEq(ResolverUID uid1, ResolverUID uid2) pure returns (bool) {\n    return ResolverUID.unwrap(uid1) == ResolverUID.unwrap(uid2);\n}\n\nfunction resolverNotEq(ResolverUID uid1, ResolverUID uid2) pure returns (bool) {\n    return ResolverUID.unwrap(uid1) != ResolverUID.unwrap(uid2);\n}\n\ntype AttestationDataRef is address;\n\nusing { attestationDataRefEq as == } for AttestationDataRef global;\n\nfunction attestationDataRefEq(AttestationDataRef uid1, AttestationDataRef uid2) pure returns (bool) {\n    return AttestationDataRef.unwrap(uid1) == AttestationDataRef.unwrap(uid2);\n}\n\ntype PackedModuleTypes is uint32;\n\ntype ModuleType is uint256;\n\nusing { moduleTypeEq as == } for ModuleType global;\nusing { moduleTypeNeq as != } for ModuleType global;\n\nfunction moduleTypeEq(ModuleType uid1, ModuleType uid2) pure returns (bool) {\n    return ModuleType.unwrap(uid1) == ModuleType.unwrap(uid2);\n}\n\nfunction moduleTypeNeq(ModuleType uid1, ModuleType uid2) pure returns (bool) {\n    return ModuleType.unwrap(uid1) != ModuleType.unwrap(uid2);\n}\n"},"src/lib/AttestationLib.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.24;\n\nimport { AttestationRequest, RevocationRequest, AttestationDataRef } from \"../DataTypes.sol\";\nimport { SSTORE2 } from \"solady/utils/SSTORE2.sol\";\n\nlibrary AttestationLib {\n    // The hash of the data type used to relay calls to the attest function. It's the value of\n    bytes32 internal constant ATTEST_REQUEST_TYPEHASH =\n        keccak256(\"AttestationRequest(address moduleAddress,uint48 expirationTime,bytes data,uint256[] moduleTypes)\");\n    // solhint-disable max-line-length\n    bytes32 internal constant ATTEST_TYPEHASH = keccak256(\n        \"SignedAttestationRequest(AttestationRequest request,uint256 nonce)AttestationRequest(address moduleAddress,uint48 expirationTime,bytes data,uint256[] moduleTypes)\"\n    );\n    // solhint-disable max-line-length\n    bytes32 internal constant ATTEST_ARRAY_TYPEHASH = keccak256(\n        \"SignedAttestationRequests(AttestationRequest[] requests,uint256 nonce)AttestationRequest(address moduleAddress,uint48 expirationTime,bytes data,uint256[] moduleTypes)\"\n    );\n\n    // The hash of the data type used to relay calls to the revoke function. It's the value of\n    bytes32 internal constant REVOKE_REQUEST_TYPEHASH = keccak256(\"RevocationRequest(address moduleAddress)\");\n    bytes32 internal constant REVOKE_TYPEHASH =\n        keccak256(\"SignedRevocationRequest(RevocationRequest request,uint256 nonce)RevocationRequest(address moduleAddress)\");\n    bytes32 internal constant REVOKE_ARRAY_TYPEHASH =\n        keccak256(\"SignedRevocationRequests(RevocationRequest[] requests,uint256 nonce)RevocationRequest(address moduleAddress)\");\n\n    /**\n     * Helper function to SSTORE2 read an attestation\n     * @param dataPointer the pointer to the attestation data\n     * @return data attestation data\n     */\n    function sload2(AttestationDataRef dataPointer) internal view returns (bytes memory data) {\n        data = SSTORE2.read(AttestationDataRef.unwrap(dataPointer));\n    }\n\n    /**\n     * Helper function to SSTORE2 write an attestation\n     * @param request the attestation request\n     * @param salt the salt to use for the deterministic address generation\n     * @return dataPointer the pointer to the attestation data\n     */\n    function sstore2(AttestationRequest calldata request, bytes32 salt) internal returns (AttestationDataRef dataPointer) {\n        /**\n         * @dev We are using CREATE2 to deterministically generate the address of the attestation data.\n         * Checking if an attestation pointer already exists, would cost more GAS in the average case.\n         */\n        dataPointer = AttestationDataRef.wrap(SSTORE2.writeDeterministic(request.data, salt));\n    }\n\n    /**\n     * Create salt for SSTORE2.\n     * The salt is constructed out of:\n     *   - attester address\n     *   - module address\n     *   - current timestamp\n     *   - chain id\n     * @param attester the attester address\n     * @param module the module address\n     * @return salt the salt\n     */\n    function sstore2Salt(address attester, address module) internal view returns (bytes32 salt) {\n        salt = keccak256(abi.encodePacked(attester, module, block.timestamp, block.chainid));\n    }\n\n    /**\n     * generate hash for EIP712 for one attestation request\n     * @param request attestation request\n     * @param nonce the nonce for attestation request\n     * @return _hash the hash\n     */\n    function hash(AttestationRequest calldata request, uint256 nonce) internal pure returns (bytes32 _hash) {\n        _hash = keccak256(\n            abi.encode(\n                ATTEST_TYPEHASH,\n                keccak256(\n                    abi.encode(\n                        ATTEST_REQUEST_TYPEHASH,\n                        request.moduleAddress,\n                        request.expirationTime,\n                        keccak256(request.data),\n                        keccak256(abi.encodePacked(request.moduleTypes))\n                    )\n                ),\n                nonce\n            )\n        );\n    }\n\n    /**\n     * generate hash for EIP712 for multiple attestation requests\n     * @param requests attestation request\n     * @param nonce the nonce for attestation request\n     * @return _hash the hash\n     */\n    function hash(AttestationRequest[] calldata requests, uint256 nonce) internal pure returns (bytes32 _hash) {\n        bytes memory concatinatedAttestations;\n\n        uint256 length = requests.length;\n        for (uint256 i; i < length; i++) {\n            concatinatedAttestations = abi.encodePacked(\n                concatinatedAttestations, // concat previous\n                keccak256(\n                    abi.encode(\n                        ATTEST_REQUEST_TYPEHASH,\n                        requests[i].moduleAddress,\n                        requests[i].expirationTime,\n                        keccak256(requests[i].data),\n                        keccak256(abi.encodePacked(requests[i].moduleTypes))\n                    )\n                )\n            );\n        }\n\n        _hash = keccak256(abi.encode(ATTEST_ARRAY_TYPEHASH, keccak256(concatinatedAttestations), nonce));\n    }\n\n    /**\n     * generate hash for EIP712 for one revocation request\n     * @param request attestation request\n     * @param nonce the nonce for attestation request\n     * @return _hash the hash\n     */\n    function hash(RevocationRequest calldata request, uint256 nonce) internal pure returns (bytes32 _hash) {\n        _hash = keccak256(abi.encode(REVOKE_TYPEHASH, keccak256(abi.encode(REVOKE_REQUEST_TYPEHASH, request.moduleAddress)), nonce));\n    }\n\n    /**\n     * generate hash for EIP712 for multiple revocation requests\n     * @param requests attestation request\n     * @param nonce the nonce for attestation request\n     * @return _hash the hash\n     */\n    function hash(RevocationRequest[] calldata requests, uint256 nonce) internal pure returns (bytes32 _hash) {\n        bytes memory concatinatedAttestations;\n\n        uint256 length = requests.length;\n        for (uint256 i; i < length; i++) {\n            concatinatedAttestations = abi.encodePacked(\n                concatinatedAttestations, // concat previous\n                keccak256(abi.encode(REVOKE_REQUEST_TYPEHASH, requests[i].moduleAddress))\n            );\n        }\n\n        _hash = keccak256(abi.encode(REVOKE_ARRAY_TYPEHASH, keccak256(concatinatedAttestations), nonce));\n    }\n}\n"},"node_modules/solady/src/utils/EIP712.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Contract for EIP-712 typed structured data hashing and signing.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EIP712.sol)\n/// @author Modified from Solbase (https://github.com/Sol-DAO/solbase/blob/main/src/utils/EIP712.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/EIP712.sol)\n///\n/// @dev Note, this implementation:\n/// - Uses `address(this)` for the `verifyingContract` field.\n/// - Does NOT use the optional EIP-712 salt.\n/// - Does NOT use any EIP-712 extensions.\n/// This is for simplicity and to save gas.\n/// If you need to customize, please fork / modify accordingly.\nabstract contract EIP712 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  CONSTANTS AND IMMUTABLES                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")`.\n    bytes32 internal constant _DOMAIN_TYPEHASH =\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    uint256 private immutable _cachedThis;\n    uint256 private immutable _cachedChainId;\n    bytes32 private immutable _cachedNameHash;\n    bytes32 private immutable _cachedVersionHash;\n    bytes32 private immutable _cachedDomainSeparator;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CONSTRUCTOR                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Cache the hashes for cheaper runtime gas costs.\n    /// In the case of upgradeable contracts (i.e. proxies),\n    /// or if the chain id changes due to a hard fork,\n    /// the domain separator will be seamlessly calculated on-the-fly.\n    constructor() {\n        _cachedThis = uint256(uint160(address(this)));\n        _cachedChainId = block.chainid;\n\n        string memory name;\n        string memory version;\n        if (!_domainNameAndVersionMayChange()) (name, version) = _domainNameAndVersion();\n        bytes32 nameHash = _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(name));\n        bytes32 versionHash =\n            _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(version));\n        _cachedNameHash = nameHash;\n        _cachedVersionHash = versionHash;\n\n        bytes32 separator;\n        if (!_domainNameAndVersionMayChange()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let m := mload(0x40) // Load the free memory pointer.\n                mstore(m, _DOMAIN_TYPEHASH)\n                mstore(add(m, 0x20), nameHash)\n                mstore(add(m, 0x40), versionHash)\n                mstore(add(m, 0x60), chainid())\n                mstore(add(m, 0x80), address())\n                separator := keccak256(m, 0xa0)\n            }\n        }\n        _cachedDomainSeparator = separator;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   FUNCTIONS TO OVERRIDE                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Please override this function to return the domain name and version.\n    /// ```\n    ///     function _domainNameAndVersion()\n    ///         internal\n    ///         pure\n    ///         virtual\n    ///         returns (string memory name, string memory version)\n    ///     {\n    ///         name = \"Solady\";\n    ///         version = \"1\";\n    ///     }\n    /// ```\n    ///\n    /// Note: If the returned result may change after the contract has been deployed,\n    /// you must override `_domainNameAndVersionMayChange()` to return true.\n    function _domainNameAndVersion()\n        internal\n        view\n        virtual\n        returns (string memory name, string memory version);\n\n    /// @dev Returns if `_domainNameAndVersion()` may change\n    /// after the contract has been deployed (i.e. after the constructor).\n    /// Default: false.\n    function _domainNameAndVersionMayChange() internal pure virtual returns (bool result) {}\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     HASHING OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the EIP-712 domain separator.\n    function _domainSeparator() internal view virtual returns (bytes32 separator) {\n        if (_domainNameAndVersionMayChange()) {\n            separator = _buildDomainSeparator();\n        } else {\n            separator = _cachedDomainSeparator;\n            if (_cachedDomainSeparatorInvalidated()) separator = _buildDomainSeparator();\n        }\n    }\n\n    /// @dev Returns the hash of the fully encoded EIP-712 message for this domain,\n    /// given `structHash`, as defined in\n    /// https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct.\n    ///\n    /// The hash can be used together with {ECDSA-recover} to obtain the signer of a message:\n    /// ```\n    ///     bytes32 digest = _hashTypedData(keccak256(abi.encode(\n    ///         keccak256(\"Mail(address to,string contents)\"),\n    ///         mailTo,\n    ///         keccak256(bytes(mailContents))\n    ///     )));\n    ///     address signer = ECDSA.recover(digest, signature);\n    /// ```\n    function _hashTypedData(bytes32 structHash) internal view virtual returns (bytes32 digest) {\n        // We will use `digest` to store the domain separator to save a bit of gas.\n        if (_domainNameAndVersionMayChange()) {\n            digest = _buildDomainSeparator();\n        } else {\n            digest = _cachedDomainSeparator;\n            if (_cachedDomainSeparatorInvalidated()) digest = _buildDomainSeparator();\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the digest.\n            mstore(0x00, 0x1901000000000000) // Store \"\\x19\\x01\".\n            mstore(0x1a, digest) // Store the domain separator.\n            mstore(0x3a, structHash) // Store the struct hash.\n            digest := keccak256(0x18, 0x42)\n            // Restore the part of the free memory slot that was overwritten.\n            mstore(0x3a, 0)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    EIP-5267 OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev See: https://eips.ethereum.org/EIPS/eip-5267\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        fields = hex\"0f\"; // `0b01111`.\n        (name, version) = _domainNameAndVersion();\n        chainId = block.chainid;\n        verifyingContract = address(this);\n        salt = salt; // `bytes32(0)`.\n        extensions = extensions; // `new uint256[](0)`.\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the EIP-712 domain separator.\n    function _buildDomainSeparator() private view returns (bytes32 separator) {\n        // We will use `separator` to store the name hash to save a bit of gas.\n        bytes32 versionHash;\n        if (_domainNameAndVersionMayChange()) {\n            (string memory name, string memory version) = _domainNameAndVersion();\n            separator = keccak256(bytes(name));\n            versionHash = keccak256(bytes(version));\n        } else {\n            separator = _cachedNameHash;\n            versionHash = _cachedVersionHash;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), separator) // Name hash.\n            mstore(add(m, 0x40), versionHash)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            separator := keccak256(m, 0xa0)\n        }\n    }\n\n    /// @dev Returns if the cached domain separator has been invalidated.\n    function _cachedDomainSeparatorInvalidated() private view returns (bool result) {\n        uint256 cachedChainId = _cachedChainId;\n        uint256 cachedThis = _cachedThis;\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := iszero(and(eq(chainid(), cachedChainId), eq(address(), cachedThis)))\n        }\n    }\n}\n"},"node_modules/solady/src/utils/SignatureCheckerLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Signature verification helper that supports both ECDSA signatures from EOAs\n/// and ERC1271 signatures from smart contract wallets like Argent and Gnosis safe.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SignatureCheckerLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/SignatureChecker.sol)\n///\n/// @dev Note:\n/// - The signature checking functions use the ecrecover precompile (0x1).\n/// - The `bytes memory signature` variants use the identity precompile (0x4)\n///   to copy memory internally.\n/// - Unlike ECDSA signatures, contract signatures are revocable.\n/// - As of Solady version 0.0.134, all `bytes signature` variants accept both\n///   regular 65-byte `(r, s, v)` and EIP-2098 `(r, vs)` short form signatures.\n///   See: https://eips.ethereum.org/EIPS/eip-2098\n///   This is for calldata efficiency on smart accounts prevalent on L2s.\n///\n/// WARNING! Do NOT use signatures as unique identifiers:\n/// - Use a nonce in the digest to prevent replay attacks on the same contract.\n/// - Use EIP-712 for the digest to prevent replay attacks across different chains and contracts.\n///   EIP-712 also enables readable signing of typed data for better user safety.\n/// This implementation does NOT check if a signature is non-malleable.\nlibrary SignatureCheckerLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*               SIGNATURE CHECKING OPERATIONS                */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns whether `signature` is valid for `signer` and `hash`.\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clean the upper 96 bits of `signer` in case they are dirty.\n            for { signer := shr(96, shl(96, signer)) } signer {} {\n                let m := mload(0x40)\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                if eq(mload(signature), 64) {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    let t :=\n                        staticcall(\n                            gas(), // Amount of gas left for the transaction.\n                            1, // Address of `ecrecover`.\n                            0x00, // Start of input.\n                            0x80, // Size of input.\n                            0x01, // Start of output.\n                            0x20 // Size of output.\n                        )\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\n                        isValid := 1\n                        mstore(0x60, 0) // Restore the zero slot.\n                        mstore(0x40, m) // Restore the free memory pointer.\n                        break\n                    }\n                }\n                if eq(mload(signature), 65) {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                    let t :=\n                        staticcall(\n                            gas(), // Amount of gas left for the transaction.\n                            1, // Address of `ecrecover`.\n                            0x00, // Start of input.\n                            0x80, // Size of input.\n                            0x01, // Start of output.\n                            0x20 // Size of output.\n                        )\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\n                        isValid := 1\n                        mstore(0x60, 0) // Restore the zero slot.\n                        mstore(0x40, m) // Restore the free memory pointer.\n                        break\n                    }\n                }\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                // Copy the `signature` over.\n                let n := add(0x20, mload(signature))\n                pop(staticcall(gas(), 4, signature, n, add(m, 0x44), n))\n                // forgefmt: disable-next-item\n                isValid := and(\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                    eq(mload(d), f),\n                    // Whether the staticcall does not revert.\n                    // This must be placed at the end of the `and` clause,\n                    // as the arguments are evaluated from right to left.\n                    staticcall(\n                        gas(), // Remaining gas.\n                        signer, // The `signer` address.\n                        m, // Offset of calldata in memory.\n                        add(returndatasize(), 0x44), // Length of calldata in memory.\n                        d, // Offset of returndata.\n                        0x20 // Length of returndata to write.\n                    )\n                )\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether `signature` is valid for `signer` and `hash`.\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\n    function isValidSignatureNowCalldata(address signer, bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clean the upper 96 bits of `signer` in case they are dirty.\n            for { signer := shr(96, shl(96, signer)) } signer {} {\n                let m := mload(0x40)\n                mstore(0x00, hash)\n                if eq(signature.length, 64) {\n                    let vs := calldataload(add(signature.offset, 0x20))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    let t :=\n                        staticcall(\n                            gas(), // Amount of gas left for the transaction.\n                            1, // Address of `ecrecover`.\n                            0x00, // Start of input.\n                            0x80, // Size of input.\n                            0x01, // Start of output.\n                            0x20 // Size of output.\n                        )\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\n                        isValid := 1\n                        mstore(0x60, 0) // Restore the zero slot.\n                        mstore(0x40, m) // Restore the free memory pointer.\n                        break\n                    }\n                }\n                if eq(signature.length, 65) {\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n                    calldatacopy(0x40, signature.offset, 0x40) // `r`, `s`.\n                    let t :=\n                        staticcall(\n                            gas(), // Amount of gas left for the transaction.\n                            1, // Address of `ecrecover`.\n                            0x00, // Start of input.\n                            0x80, // Size of input.\n                            0x01, // Start of output.\n                            0x20 // Size of output.\n                        )\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\n                        isValid := 1\n                        mstore(0x60, 0) // Restore the zero slot.\n                        mstore(0x40, m) // Restore the free memory pointer.\n                        break\n                    }\n                }\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), signature.length)\n                // Copy the `signature` over.\n                calldatacopy(add(m, 0x64), signature.offset, signature.length)\n                // forgefmt: disable-next-item\n                isValid := and(\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                    eq(mload(d), f),\n                    // Whether the staticcall does not revert.\n                    // This must be placed at the end of the `and` clause,\n                    // as the arguments are evaluated from right to left.\n                    staticcall(\n                        gas(), // Remaining gas.\n                        signer, // The `signer` address.\n                        m, // Offset of calldata in memory.\n                        add(signature.length, 0x64), // Length of calldata in memory.\n                        d, // Offset of returndata.\n                        0x20 // Length of returndata to write.\n                    )\n                )\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether the signature (`r`, `vs`) is valid for `signer` and `hash`.\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\n    function isValidSignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clean the upper 96 bits of `signer` in case they are dirty.\n            for { signer := shr(96, shl(96, signer)) } signer {} {\n                let m := mload(0x40)\n                mstore(0x00, hash)\n                mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                mstore(0x40, r) // `r`.\n                mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                let t :=\n                    staticcall(\n                        gas(), // Amount of gas left for the transaction.\n                        1, // Address of `ecrecover`.\n                        0x00, // Start of input.\n                        0x80, // Size of input.\n                        0x01, // Start of output.\n                        0x20 // Size of output.\n                    )\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\n                    isValid := 1\n                    mstore(0x60, 0) // Restore the zero slot.\n                    mstore(0x40, m) // Restore the free memory pointer.\n                    break\n                }\n\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), 65) // Length of the signature.\n                mstore(add(m, 0x64), r) // `r`.\n                mstore(add(m, 0x84), mload(0x60)) // `s`.\n                mstore8(add(m, 0xa4), mload(0x20)) // `v`.\n                // forgefmt: disable-next-item\n                isValid := and(\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                    eq(mload(d), f),\n                    // Whether the staticcall does not revert.\n                    // This must be placed at the end of the `and` clause,\n                    // as the arguments are evaluated from right to left.\n                    staticcall(\n                        gas(), // Remaining gas.\n                        signer, // The `signer` address.\n                        m, // Offset of calldata in memory.\n                        0xa5, // Length of calldata in memory.\n                        d, // Offset of returndata.\n                        0x20 // Length of returndata to write.\n                    )\n                )\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether the signature (`v`, `r`, `s`) is valid for `signer` and `hash`.\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\n    function isValidSignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clean the upper 96 bits of `signer` in case they are dirty.\n            for { signer := shr(96, shl(96, signer)) } signer {} {\n                let m := mload(0x40)\n                mstore(0x00, hash)\n                mstore(0x20, and(v, 0xff)) // `v`.\n                mstore(0x40, r) // `r`.\n                mstore(0x60, s) // `s`.\n                let t :=\n                    staticcall(\n                        gas(), // Amount of gas left for the transaction.\n                        1, // Address of `ecrecover`.\n                        0x00, // Start of input.\n                        0x80, // Size of input.\n                        0x01, // Start of output.\n                        0x20 // Size of output.\n                    )\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\n                    isValid := 1\n                    mstore(0x60, 0) // Restore the zero slot.\n                    mstore(0x40, m) // Restore the free memory pointer.\n                    break\n                }\n\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), 65) // Length of the signature.\n                mstore(add(m, 0x64), r) // `r`.\n                mstore(add(m, 0x84), s) // `s`.\n                mstore8(add(m, 0xa4), v) // `v`.\n                // forgefmt: disable-next-item\n                isValid := and(\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                    eq(mload(d), f),\n                    // Whether the staticcall does not revert.\n                    // This must be placed at the end of the `and` clause,\n                    // as the arguments are evaluated from right to left.\n                    staticcall(\n                        gas(), // Remaining gas.\n                        signer, // The `signer` address.\n                        m, // Offset of calldata in memory.\n                        0xa5, // Length of calldata in memory.\n                        d, // Offset of returndata.\n                        0x20 // Length of returndata to write.\n                    )\n                )\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     ERC1271 OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns whether `signature` is valid for `hash` for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            // Copy the `signature` over.\n            let n := add(0x20, mload(signature))\n            pop(staticcall(gas(), 4, signature, n, add(m, 0x44), n))\n            // forgefmt: disable-next-item\n            isValid := and(\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                eq(mload(d), f),\n                // Whether the staticcall does not revert.\n                // This must be placed at the end of the `and` clause,\n                // as the arguments are evaluated from right to left.\n                staticcall(\n                    gas(), // Remaining gas.\n                    signer, // The `signer` address.\n                    m, // Offset of calldata in memory.\n                    add(returndatasize(), 0x44), // Length of calldata in memory.\n                    d, // Offset of returndata.\n                    0x20 // Length of returndata to write.\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether `signature` is valid for `hash` for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNowCalldata(\n        address signer,\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view returns (bool isValid) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), signature.length)\n            // Copy the `signature` over.\n            calldatacopy(add(m, 0x64), signature.offset, signature.length)\n            // forgefmt: disable-next-item\n            isValid := and(\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                eq(mload(d), f),\n                // Whether the staticcall does not revert.\n                // This must be placed at the end of the `and` clause,\n                // as the arguments are evaluated from right to left.\n                staticcall(\n                    gas(), // Remaining gas.\n                    signer, // The `signer` address.\n                    m, // Offset of calldata in memory.\n                    add(signature.length, 0x64), // Length of calldata in memory.\n                    d, // Offset of returndata.\n                    0x20 // Length of returndata to write.\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether the signature (`r`, `vs`) is valid for `hash`\n    /// for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), 65) // Length of the signature.\n            mstore(add(m, 0x64), r) // `r`.\n            mstore(add(m, 0x84), shr(1, shl(1, vs))) // `s`.\n            mstore8(add(m, 0xa4), add(shr(255, vs), 27)) // `v`.\n            // forgefmt: disable-next-item\n            isValid := and(\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                eq(mload(d), f),\n                // Whether the staticcall does not revert.\n                // This must be placed at the end of the `and` clause,\n                // as the arguments are evaluated from right to left.\n                staticcall(\n                    gas(), // Remaining gas.\n                    signer, // The `signer` address.\n                    m, // Offset of calldata in memory.\n                    0xa5, // Length of calldata in memory.\n                    d, // Offset of returndata.\n                    0x20 // Length of returndata to write.\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether the signature (`v`, `r`, `s`) is valid for `hash`\n    /// for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), 65) // Length of the signature.\n            mstore(add(m, 0x64), r) // `r`.\n            mstore(add(m, 0x84), s) // `s`.\n            mstore8(add(m, 0xa4), v) // `v`.\n            // forgefmt: disable-next-item\n            isValid := and(\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                eq(mload(d), f),\n                // Whether the staticcall does not revert.\n                // This must be placed at the end of the `and` clause,\n                // as the arguments are evaluated from right to left.\n                staticcall(\n                    gas(), // Remaining gas.\n                    signer, // The `signer` address.\n                    m, // Offset of calldata in memory.\n                    0xa5, // Length of calldata in memory.\n                    d, // Offset of returndata.\n                    0x20 // Length of returndata to write.\n                )\n            )\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     HASHING OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, hash) // Store into scratch space for keccak256.\n            mstore(0x00, \"\\x00\\x00\\x00\\x00\\x19Ethereum Signed Message:\\n32\") // 28 bytes.\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\n        }\n    }\n\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    /// Note: Supports lengths of `s` up to 999999 bytes.\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let sLength := mload(s)\n            let o := 0x20\n            mstore(o, \"\\x19Ethereum Signed Message:\\n\") // 26 bytes, zero-right-padded.\n            mstore(0x00, 0x00)\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\n            for { let temp := sLength } 1 {} {\n                o := sub(o, 1)\n                mstore8(o, add(48, mod(temp, 10)))\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\n            mstore(s, sLength) // Restore the length.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   EMPTY CALLDATA HELPERS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns an empty calldata bytes.\n    function emptySignature() internal pure returns (bytes calldata signature) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            signature.length := 0\n        }\n    }\n}\n"},"src/external/IExternalSchemaValidator.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.24;\n\nimport { AttestationRecord } from \"../DataTypes.sol\";\nimport { IERC165 } from \"forge-std/interfaces/IERC165.sol\";\n\n/**\n * @title The interface of an optional schema resolver.\n */\ninterface IExternalSchemaValidator is IERC165 {\n    /**\n     * @notice Validates an attestation request.\n     */\n    function validateSchema(AttestationRecord calldata attestation) external returns (bool);\n\n    /**\n     * @notice Validates an array of attestation requests.\n     */\n    function validateSchema(AttestationRecord[] calldata attestations) external returns (bool);\n}\n"},"src/external/IExternalResolver.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.24;\n\nimport { AttestationRecord, ModuleRecord } from \"../DataTypes.sol\";\nimport { IERC165 } from \"forge-std/interfaces/IERC165.sol\";\n\n/**\n * @title The interface of an optional schema resolver.\n * @dev The resolver is responsible for validating the schema and attestation data.\n * @dev The resolver is also responsible for processing the attestation and revocation requests.\n *\n */\ninterface IExternalResolver is IERC165 {\n    /**\n     * @dev Processes an attestation and verifies whether it's valid.\n     *\n     * @param attestation The new attestation.\n     *\n     * @return Whether the attestation is valid.\n     */\n    function resolveAttestation(AttestationRecord calldata attestation) external payable returns (bool);\n\n    function resolveAttestation(AttestationRecord[] calldata attestation) external payable returns (bool);\n\n    /**\n     * @dev Processes an attestation revocation and verifies if it can be revoked.\n     *\n     * @param attestation The existing attestation to be revoked.\n     *\n     * @return Whether the attestation can be revoked.\n     */\n    function resolveRevocation(AttestationRecord calldata attestation) external payable returns (bool);\n    function resolveRevocation(AttestationRecord[] calldata attestation) external payable returns (bool);\n\n    /**\n     * @dev Processes a Module Registration\n     *\n     * @param sender The msg.sender of the module registration\n     * @param moduleAddress address of the module\n     * @param record Module registration artefact\n     *\n     * @return Whether the registration is valid\n     */\n    function resolveModuleRegistration(\n        address sender,\n        address moduleAddress,\n        ModuleRecord calldata record,\n        bytes calldata resolverContext\n    )\n        external\n        payable\n        returns (bool);\n}\n"},"src/interfaces/IERC7484.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { ModuleType } from \"../DataTypes.sol\";\n\ninterface IERC7484 {\n    event NewTrustedAttesters(address indexed smartAccount);\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*          Check with Registry internal attesters            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function check(address module) external view;\n\n    function checkForAccount(address smartAccount, address module) external view;\n\n    function check(address module, ModuleType moduleType) external view;\n\n    function checkForAccount(address smartAccount, address module, ModuleType moduleType) external view;\n\n    /**\n     * Allows Smart Accounts - the end users of the registry - to appoint\n     * one or many attesters as trusted.\n     * @dev this function reverts, if address(0), or duplicates are provided in attesters[]\n     *\n     * @param threshold The minimum number of attestations required for a module\n     *                  to be considered secure.\n     * @param attesters The addresses of the attesters to be trusted.\n     */\n    function trustAttesters(uint8 threshold, address[] calldata attesters) external;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              Check with external attester(s)               */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function check(address module, address[] calldata attesters, uint256 threshold) external view;\n\n    function check(address module, ModuleType moduleType, address[] calldata attesters, uint256 threshold) external view;\n}\n"},"src/core/AttestationManager.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.24;\n\nimport {\n    AttestationDataRef,\n    AttestationRecord,\n    AttestationRequest,\n    ModuleType,\n    ResolverUID,\n    RevocationRequest,\n    SchemaUID\n} from \"../DataTypes.sol\";\nimport { SchemaManager } from \"./SchemaManager.sol\";\nimport { ModuleManager } from \"./ModuleManager.sol\";\nimport { TrustManagerExternalAttesterList } from \"./TrustManagerExternalAttesterList.sol\";\nimport { StubLib } from \"../lib/StubLib.sol\";\nimport { AttestationLib } from \"../lib/AttestationLib.sol\";\nimport { ModuleTypeLib } from \"../lib/ModuleTypeLib.sol\";\nimport { IRegistry } from \"../IRegistry.sol\";\n\nimport { EMPTY_ATTESTATION_REF, EMPTY_RESOLVER_UID, _time, ZERO_TIMESTAMP } from \"../Common.sol\";\n\n/**\n * AttestationManager handles the registry's internal storage of new attestations and revocation of attestation\n * @dev This contract is abstract and provides internal utility functions to store attestations and revocations.\n *\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\n */\nabstract contract AttestationManager is IRegistry, ModuleManager, SchemaManager, TrustManagerExternalAttesterList {\n    using StubLib for *;\n    using AttestationLib for AttestationDataRef;\n    using AttestationLib for AttestationRequest;\n    using AttestationLib for AttestationRequest[];\n    using AttestationLib for address;\n    using ModuleTypeLib for ModuleType[];\n\n    mapping(address module => mapping(address attester => AttestationRecord attestation)) internal $moduleToAttesterToAttestations;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      Attestation                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * Processes an attestation request and stores the attestation in the registry.\n     * If the attestation was made for a module that was not registered, the function will revert.\n     * function will get the external Schema Validator for the supplied SchemaUID\n     *         and call it, if an external `IExternalSchemaValidator` was set\n     * function will get the external `IExternalResolver` for the module - that the attestation is for\n     *        and call it, if an external Resolver was set\n     * @param attester The address of the attesting account.\n     * @param schemaUID the UID of the schema that the attestation is made for\n     * @param request AttestationRequest send by attester via `calldata`\n     */\n    function _attest(address attester, SchemaUID schemaUID, AttestationRequest calldata request) internal {\n        (AttestationRecord memory record, ResolverUID resolverUID) =\n            _storeAttestation({ schemaUID: schemaUID, attester: attester, request: request });\n\n        record.requireExternalSchemaValidation({ $schema: schemas[schemaUID] });\n        record.requireExternalResolverOnAttestation({ $resolver: $resolvers[resolverUID] });\n    }\n\n    /**\n     * Processes an array of attestation requests  and stores the attestations in the registry.\n     * If the attestation was made for a module that was not registered, the function will revert.\n     * function will get the external Schema Validator for the supplied SchemaUID\n     *         and call it, if an external IExternalSchemaValidator was set\n     * function will get the external IExternalResolver for the module - that the attestation is for\n     *        and call it, if an external Resolver was set\n     */\n    function _attest(address attester, SchemaUID schemaUID, AttestationRequest[] calldata requests) internal {\n        uint256 length = requests.length;\n        AttestationRecord[] memory records = new AttestationRecord[](length);\n        // loop will check that the batched attestation is made ONLY for the same resolver\n        ResolverUID resolverUID;\n        for (uint256 i; i < length; i++) {\n            ResolverUID resolverUID_cache;\n            // save the attestation record into records array.\n            (records[i], resolverUID_cache) = _storeAttestation({ schemaUID: schemaUID, attester: attester, request: requests[i] });\n            // cache the first resolverUID and compare it to the rest\n            // If the resolverUID is different, revert\n            // @dev if you want to use different resolvers, make different attestation calls\n            if (i == 0) resolverUID = resolverUID_cache;\n            else if (resolverUID_cache != resolverUID) revert DifferentResolvers();\n        }\n\n        // Use StubLib to call schema Validation and resolver if needed\n        records.requireExternalSchemaValidation({ $schema: schemas[schemaUID] });\n        records.requireExternalResolverOnAttestation({ $resolver: $resolvers[resolverUID] });\n    }\n\n    /**\n     * Stores an attestation in the registry storage.\n     * The bytes encoded `AttestationRequest.Data` is not stored directly into the registry storage,\n     * but rather stored with `SSTORE2`. `SSTORE2/SLOAD2` is writing and reading contract storage\n     * paying a fraction of the cost, it uses contract code as storage, writing data takes the\n     * form of contract creations and reading data uses `EXTCODECOPY`.\n     * since attestation data is supposed to be immutable, it is a good candidate for `SSTORE2`\n     *\n     * @dev This function will revert if the same module is attested twice by the same attester.\n     *      If you want to re-attest, you have to revoke your attestation first, and then attest again.\n     *\n     * @param attester The address of the attesting account.\n     * @param request The AttestationRequest that was supplied via calldata\n     * @return record The AttestationRecord of what was written into registry storage\n     * @return resolverUID The resolverUID in charge for the module\n     */\n    function _storeAttestation(\n        SchemaUID schemaUID,\n        address attester,\n        AttestationRequest calldata request\n    )\n        internal\n        returns (AttestationRecord memory record, ResolverUID resolverUID)\n    {\n        // if schema behind schemaUID is not registered, revert.\n        if (schemas[schemaUID].registeredAt == ZERO_TIMESTAMP) revert InvalidSchema();\n\n        uint48 timeNow = _time();\n        // Ensure that either no expiration time was set or that it was set in the future.\n        if (request.expirationTime != ZERO_TIMESTAMP && request.expirationTime <= timeNow) {\n            revert InvalidExpirationTime();\n        }\n        // caching module address.\n        address module = request.moduleAddress;\n        AttestationRecord storage $record = $getAttestation({ module: module, attester: attester });\n        // If the attestation was already made for module, but not revoked, revert.\n        if ($record.time != ZERO_TIMESTAMP && $record.revocationTime == ZERO_TIMESTAMP) {\n            revert AlreadyAttested();\n        }\n        // SLOAD the resolverUID from the moduleRecord\n        resolverUID = $moduleAddrToRecords[module].resolverUID;\n        // Ensure that attestation is for module that was registered.\n        if (resolverUID == EMPTY_RESOLVER_UID) {\n            revert ModuleNotFoundInRegistry(module);\n        }\n\n        // use SSTORE2 to store the data in attestationRequest\n        // this will revert, if in a batched attestation,\n        // the same data is used twice by the same attester for the same module since the salt will be the same\n        AttestationDataRef sstore2Pointer = request.sstore2({ salt: attester.sstore2Salt(module) });\n\n        // write into memory allocated record, since that is the return value\n        record = AttestationRecord({\n            time: timeNow,\n            expirationTime: request.expirationTime,\n            revocationTime: uint48(ZERO_TIMESTAMP),\n            moduleTypes: request.moduleTypes.pack(),\n            schemaUID: schemaUID,\n            moduleAddress: module,\n            attester: attester,\n            dataPointer: sstore2Pointer\n        });\n        // SSTORE attestation to registry storage\n        $moduleToAttesterToAttestations[module][attester] = record;\n\n        emit Attested({ moduleAddress: module, attester: attester, schemaUID: schemaUID, sstore2Pointer: sstore2Pointer });\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       Revocation                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * Revoke a single Revocation Request\n     * This function will write the `RevocationRequest` into storage, and get the stored `RevocationRecord` back,\n     * and pass the `RevocationRecord` to the resolver to check if the revocation is valid\n     */\n    function _revoke(address attester, RevocationRequest calldata request) internal {\n        (AttestationRecord memory record, ResolverUID resolverUID) = _storeRevocation(attester, request);\n        record.tryExternalResolverOnRevocation({ $resolver: $resolvers[resolverUID] });\n    }\n\n    /**\n     * Revoke an array Revocation Request\n     * This function will write the `RevocationRequest` into storage, and get the stored `RevocationRecord` back,\n     * and pass the `RevocationRecord` to the resolver to check if the revocation is valid\n     */\n    function _revoke(address attester, RevocationRequest[] calldata requests) internal {\n        uint256 length = requests.length;\n        AttestationRecord[] memory records = new AttestationRecord[](length);\n        ResolverUID resolverUID;\n        // loop over revocation requests. This function will revert if different resolverUIDs\n        // are responsible for the modules that are subject of the revocation. This is to reduce complexity\n        // @dev if you want to revoke attestations from different resolvers, make different revocation calls\n        for (uint256 i; i < length; i++) {\n            ResolverUID resolverUID_cache;\n            (records[i], resolverUID_cache) = _storeRevocation(attester, requests[i]);\n            if (i == 0) resolverUID = resolverUID_cache;\n            else if (resolverUID_cache != resolverUID) revert DifferentResolvers();\n        }\n\n        // No schema validation required during revocation. The attestation data was already checked against\n        records.tryExternalResolverOnRevocation({ $resolver: $resolvers[resolverUID] });\n    }\n\n    /**\n     * Gets the AttestationRecord for the supplied RevocationRequest and stores the revocation time in the registry storage\n     * @param revoker The address of the attesting account.\n     * @param request The AttestationRequest that was supplied via calldata\n     * @return record The AttestationRecord of what was written into registry storage\n     * @return resolverUID The resolverUID in charge for the module\n     */\n    function _storeRevocation(\n        address revoker,\n        RevocationRequest calldata request\n    )\n        internal\n        returns (AttestationRecord memory record, ResolverUID resolverUID)\n    {\n        AttestationRecord storage $attestation = $moduleToAttesterToAttestations[request.moduleAddress][revoker];\n\n        // SLOAD entire record. This will later be passed to the resolver\n        record = $attestation;\n        resolverUID = $moduleAddrToRecords[request.moduleAddress].resolverUID;\n\n        // Ensure that we aren't attempting to revoke a non-existing attestation.\n        if (record.dataPointer == EMPTY_ATTESTATION_REF) {\n            revert AttestationNotFound();\n        }\n\n        // Allow only original attesters to revoke their attestations.\n        if (record.attester != revoker) {\n            revert AccessDenied();\n        }\n\n        // Ensure that we aren't trying to revoke the same attestation twice.\n        if (record.revocationTime != ZERO_TIMESTAMP) {\n            revert AlreadyRevoked();\n        }\n\n        // SSTORE revocation time to registry storage\n        // set revocation time to NOW\n        $attestation.revocationTime = _time();\n\n        emit Revoked({ moduleAddress: request.moduleAddress, revoker: revoker, schema: record.schemaUID });\n    }\n\n    /**\n     * Returns a storage reference to attestation records for the given module and attesters.\n     * This function is expected to be used by `TrustManager` and `TrustManagerExternalAttesterList`\n     */\n    function $getAttestation(address module, address attester) internal view override returns (AttestationRecord storage $attestation) {\n        $attestation = $moduleToAttesterToAttestations[module][attester];\n    }\n}\n"},"node_modules/solady/src/utils/SSTORE2.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Solady (https://github.com/vectorized/solmady/blob/main/src/utils/SSTORE2.sol)\n/// @author Saw-mon-and-Natalie (https://github.com/Saw-mon-and-Natalie)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\nlibrary SSTORE2 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev We skip the first byte as it's a STOP opcode,\n    /// which ensures the contract can't be called.\n    uint256 internal constant DATA_OFFSET = 1;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Unable to deploy the storage contract.\n    error DeploymentFailed();\n\n    /// @dev The storage contract address is invalid.\n    error InvalidPointer();\n\n    /// @dev Attempt to read outside of the storage contract's bytecode bounds.\n    error ReadOutOfBounds();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         WRITE LOGIC                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Writes `data` into the bytecode of a storage contract and returns its address.\n    function write(bytes memory data) internal returns (address pointer) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let originalDataLength := mload(data)\n\n            // Add 1 to data size since we are prefixing it with a STOP opcode.\n            let dataSize := add(originalDataLength, DATA_OFFSET)\n\n            /**\n             * ------------------------------------------------------------------------------+\n             * Opcode      | Mnemonic        | Stack                   | Memory              |\n             * ------------------------------------------------------------------------------|\n             * 61 dataSize | PUSH2 dataSize  | dataSize                |                     |\n             * 80          | DUP1            | dataSize dataSize       |                     |\n             * 60 0xa      | PUSH1 0xa       | 0xa dataSize dataSize   |                     |\n             * 3D          | RETURNDATASIZE  | 0 0xa dataSize dataSize |                     |\n             * 39          | CODECOPY        | dataSize                | [0..dataSize): code |\n             * 3D          | RETURNDATASIZE  | 0 dataSize              | [0..dataSize): code |\n             * F3          | RETURN          |                         | [0..dataSize): code |\n             * 00          | STOP            |                         |                     |\n             * ------------------------------------------------------------------------------+\n             * @dev Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n             * Also PUSH2 is used since max contract size cap is 24,576 bytes which is less than 2 ** 16.\n             */\n            mstore(\n                // Do a out-of-gas revert if `dataSize` is more than 2 bytes.\n                // The actual EVM limit may be smaller and may change over time.\n                add(data, gt(dataSize, 0xffff)),\n                // Left shift `dataSize` by 64 so that it lines up with the 0000 after PUSH2.\n                or(0xfd61000080600a3d393df300, shl(0x40, dataSize))\n            )\n\n            // Deploy a new contract with the generated creation code.\n            pointer := create(0, add(data, 0x15), add(dataSize, 0xa))\n\n            // If `pointer` is zero, revert.\n            if iszero(pointer) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Restore original length of the variable size `data`.\n            mstore(data, originalDataLength)\n        }\n    }\n\n    /// @dev Writes `data` into the bytecode of a storage contract with `salt`\n    /// and returns its deterministic address.\n    function writeDeterministic(bytes memory data, bytes32 salt)\n        internal\n        returns (address pointer)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let originalDataLength := mload(data)\n            let dataSize := add(originalDataLength, DATA_OFFSET)\n\n            mstore(\n                // Do a out-of-gas revert if `dataSize` is more than 2 bytes.\n                // The actual EVM limit may be smaller and may change over time.\n                add(data, gt(dataSize, 0xffff)),\n                // Left shift `dataSize` by 64 so that it lines up with the 0000 after PUSH2.\n                or(0xfd61000080600a3d393df300, shl(0x40, dataSize))\n            )\n\n            // Deploy a new contract with the generated creation code.\n            pointer := create2(0, add(data, 0x15), add(dataSize, 0xa), salt)\n\n            // If `pointer` is zero, revert.\n            if iszero(pointer) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Restore original length of the variable size `data`.\n            mstore(data, originalDataLength)\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the storage contract for `data`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHash(bytes memory data) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let originalDataLength := mload(data)\n            let dataSize := add(originalDataLength, DATA_OFFSET)\n\n            // Do a out-of-gas revert if `dataSize` is more than 2 bytes.\n            // The actual EVM limit may be smaller and may change over time.\n            returndatacopy(returndatasize(), returndatasize(), shr(16, dataSize))\n\n            mstore(data, or(0x61000080600a3d393df300, shl(0x40, dataSize)))\n\n            hash := keccak256(add(data, 0x15), add(dataSize, 0xa))\n\n            // Restore original length of the variable size `data`.\n            mstore(data, originalDataLength)\n        }\n    }\n\n    /// @dev Returns the address of the storage contract for `data`\n    /// deployed with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress(bytes memory data, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        bytes32 hash = initCodeHash(data);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, hash)\n            mstore(0x01, shl(96, deployer))\n            mstore(0x15, salt)\n            predicted := keccak256(0x00, 0x55)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x35, 0)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         READ LOGIC                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns all the `data` from the bytecode of the storage contract at `pointer`.\n    function read(address pointer) internal view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let pointerCodesize := extcodesize(pointer)\n            if iszero(pointerCodesize) {\n                // Store the function selector of `InvalidPointer()`.\n                mstore(0x00, 0x11052bb4)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Offset all indices by 1 to skip the STOP opcode.\n            let size := sub(pointerCodesize, DATA_OFFSET)\n\n            // Get the pointer to the free memory and allocate\n            // enough 32-byte words for the data and the length of the data,\n            // then copy the code to the allocated memory.\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\n            mstore(data, size)\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\n            extcodecopy(pointer, add(data, 0x20), DATA_OFFSET, size)\n        }\n    }\n\n    /// @dev Returns the `data` from the bytecode of the storage contract at `pointer`,\n    /// from the byte at `start`, to the end of the data stored.\n    function read(address pointer, uint256 start) internal view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let pointerCodesize := extcodesize(pointer)\n            if iszero(pointerCodesize) {\n                // Store the function selector of `InvalidPointer()`.\n                mstore(0x00, 0x11052bb4)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // If `!(pointer.code.size > start)`, reverts.\n            // This also handles the case where `start + DATA_OFFSET` overflows.\n            if iszero(gt(pointerCodesize, start)) {\n                // Store the function selector of `ReadOutOfBounds()`.\n                mstore(0x00, 0x84eb0dd1)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            let size := sub(pointerCodesize, add(start, DATA_OFFSET))\n\n            // Get the pointer to the free memory and allocate\n            // enough 32-byte words for the data and the length of the data,\n            // then copy the code to the allocated memory.\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\n            mstore(data, size)\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\n            extcodecopy(pointer, add(data, 0x20), add(start, DATA_OFFSET), size)\n        }\n    }\n\n    /// @dev Returns the `data` from the bytecode of the storage contract at `pointer`,\n    /// from the byte at `start`, to the byte at `end` (exclusive) of the data stored.\n    function read(address pointer, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory data)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let pointerCodesize := extcodesize(pointer)\n            if iszero(pointerCodesize) {\n                // Store the function selector of `InvalidPointer()`.\n                mstore(0x00, 0x11052bb4)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // If `!(pointer.code.size > end) || (start > end)`, revert.\n            // This also handles the cases where\n            // `end + DATA_OFFSET` or `start + DATA_OFFSET` overflows.\n            if iszero(\n                and(\n                    gt(pointerCodesize, end), // Within bounds.\n                    iszero(gt(start, end)) // Valid range.\n                )\n            ) {\n                // Store the function selector of `ReadOutOfBounds()`.\n                mstore(0x00, 0x84eb0dd1)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            let size := sub(end, start)\n\n            // Get the pointer to the free memory and allocate\n            // enough 32-byte words for the data and the length of the data,\n            // then copy the code to the allocated memory.\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\n            mstore(data, size)\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\n            extcodecopy(pointer, add(data, 0x20), add(start, DATA_OFFSET), size)\n        }\n    }\n}\n"},"node_modules/forge-std/src/interfaces/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    /// uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    /// `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"},"src/core/SchemaManager.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.24;\n\nimport { SchemaRecord, SchemaUID } from \"../DataTypes.sol\";\nimport { IExternalSchemaValidator } from \"../external/IExternalSchemaValidator.sol\";\nimport { UIDLib } from \"../lib/Helpers.sol\";\n\nimport { ZERO_TIMESTAMP, _time } from \"../Common.sol\";\nimport { IRegistry } from \"../IRegistry.sol\";\n\n/**\n * Allows the creation registration and creation of schemas.\n *    Schemas are used to describe attestation data. It is recommended to use ABI encoded data as schema.\n *    An external schema validator contract may be provided,\n *    which  will be called for every attestation made against the schema.\n *    arbitrary checks may be implemented, by SchemaValidators\n *\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\n */\nabstract contract SchemaManager is IRegistry {\n    using UIDLib for SchemaRecord;\n\n    // The global mapping between schema records and their IDs.\n    mapping(SchemaUID uid => SchemaRecord schemaRecord) internal schemas;\n\n    /**\n     * If a validator is not address(0), we check if it supports the IExternalSchemaValidator interface\n     */\n    modifier onlySchemaValidator(IExternalSchemaValidator validator) {\n        if (address(validator) != address(0) && !validator.supportsInterface(type(IExternalSchemaValidator).interfaceId)) {\n            revert InvalidSchemaValidator(validator);\n        }\n        _;\n    }\n\n    /**\n     * @inheritdoc IRegistry\n     */\n    function registerSchema(\n        string calldata schema,\n        IExternalSchemaValidator validator\n    )\n        external\n        onlySchemaValidator(validator)\n        returns (SchemaUID uid)\n    {\n        SchemaRecord memory schemaRecord = SchemaRecord({ validator: validator, registeredAt: _time(), schema: schema });\n\n        // Computing a unique ID for the schema using its properties\n        uid = schemaRecord.getUID();\n\n        // check if schema with this UID already exists.\n        // overwriting a schema is not allowed\n        if (schemas[uid].registeredAt != ZERO_TIMESTAMP) revert SchemaAlreadyExists(uid);\n\n        // Storing schema in the _schemas mapping\n        schemas[uid] = schemaRecord;\n\n        emit SchemaRegistered(uid, msg.sender);\n    }\n\n    /**\n     * @inheritdoc IRegistry\n     */\n    function findSchema(SchemaUID uid) external view override returns (SchemaRecord memory) {\n        return schemas[uid];\n    }\n}\n"},"src/core/ModuleManager.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.24;\n\nimport { ModuleDeploymentLib } from \"../lib/ModuleDeploymentLib.sol\";\nimport { StubLib } from \"../lib/StubLib.sol\";\n\nimport { _isContract, EMPTY_RESOLVER_UID, ZERO_ADDRESS } from \"../Common.sol\";\nimport { ResolverRecord, ModuleRecord, ResolverUID } from \"../DataTypes.sol\";\nimport { ResolverManager } from \"./ResolverManager.sol\";\nimport { IRegistry } from \"../IRegistry.sol\";\n\n/**\n * In order to separate msg.sender context from registry,\n * interactions with external Factories are done with this Trampoline contract.\n */\ncontract FactoryTrampoline {\n    error FactoryCallFailed(address factory);\n\n    /**\n     * @param factory the address of the factory to call\n     * @param callOnFactory the call data to send to the factory\n     * @return moduleAddress the moduleAddress that was returned by the\n     */\n    function deployViaFactory(address factory, bytes memory callOnFactory) external payable returns (address moduleAddress) {\n        // call external factory to deploy module\n        bool success;\n        /* solhint-disable no-inline-assembly */\n        assembly (\"memory-safe\") {\n            success := call(gas(), factory, callvalue(), add(callOnFactory, 0x20), mload(callOnFactory), 0, 32)\n            moduleAddress := mload(0)\n        }\n        if (!success) {\n            revert FactoryCallFailed(factory);\n        }\n    }\n}\n\n/**\n * In order for Attesters to be able to make statements about a Module, the Module first needs to be registered on the Registry.\n * This can be done as part of or after Module deployment. On registration, every module is tied to a\n * [ResolverManager](../ModuleManager.sol/abstract.ResolverManager.html) that is triggered on certain registry actions.\n *\n * The ModuleManager contract is responsible for handling module the registration,\n *           storage and retrieval of modules on the Registry.\n *           This contract inherits from the `IModule` interface\n * The primary responsibility of the Module is to deploy and manage modules. A module is a smart contract\n * that has been deployed through the Module. The details of each module, such as its address, resolver UID\n * sender address, deploy parameters hash, and additional metadata are stored in\n *        a struct and mapped to the module's address in\n * the `_modules` mapping for easy access and management.\n * @dev The module developer select the resolver to be used for attestations and revocations made of the module.\n *    @dev Important: only module registrations made through the `deployModule()`  function are frontrun protected.\n *\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\n */\nabstract contract ModuleManager is IRegistry, ResolverManager {\n    using ModuleDeploymentLib for bytes;\n    using ModuleDeploymentLib for address;\n    using StubLib for *;\n\n    mapping(address moduleAddress => ModuleRecord moduleRecord) internal $moduleAddrToRecords;\n\n    FactoryTrampoline private immutable FACTORY_TRAMPOLINE;\n\n    constructor() {\n        FACTORY_TRAMPOLINE = new FactoryTrampoline();\n    }\n\n    /**\n     * @inheritdoc IRegistry\n     */\n    function deployModule(\n        bytes32 salt,\n        ResolverUID resolverUID,\n        bytes calldata initCode,\n        bytes calldata metadata,\n        bytes calldata resolverContext\n    )\n        external\n        payable\n        returns (address moduleAddress)\n    {\n        ResolverRecord storage $resolver = $resolvers[resolverUID];\n        if ($resolver.resolverOwner == ZERO_ADDRESS) revert InvalidResolverUID(resolverUID);\n\n        moduleAddress = initCode.deploy(salt);\n        // _storeModuleRecord() will check if module is already registered,\n        // which should prevent reentry to any deploy function\n        ModuleRecord memory record =\n            _storeModuleRecord({ moduleAddress: moduleAddress, sender: msg.sender, resolverUID: resolverUID, metadata: metadata });\n\n        record.requireExternalResolverOnModuleRegistration({\n            moduleAddress: moduleAddress,\n            $resolver: $resolver,\n            resolverContext: resolverContext\n        });\n    }\n\n    /**\n     * @inheritdoc IRegistry\n     */\n    function calcModuleAddress(bytes32 salt, bytes calldata initCode) external view returns (address) {\n        return initCode.calcAddress(salt);\n    }\n\n    /**\n     * @inheritdoc IRegistry\n     */\n    function registerModule(\n        ResolverUID resolverUID,\n        address moduleAddress,\n        bytes calldata metadata,\n        bytes calldata resolverContext\n    )\n        external\n    {\n        ResolverRecord storage $resolver = $resolvers[resolverUID];\n\n        // ensure that non-zero resolverUID was provided\n        if ($resolver.resolverOwner == ZERO_ADDRESS) revert InvalidResolverUID(resolverUID);\n\n        ModuleRecord memory record = _storeModuleRecord({\n            moduleAddress: moduleAddress,\n            sender: ZERO_ADDRESS, // setting sender to address(0) since anyone can invoke this function\n            resolverUID: resolverUID,\n            metadata: metadata\n        });\n\n        // resolve module registration\n        record.requireExternalResolverOnModuleRegistration({\n            moduleAddress: moduleAddress,\n            $resolver: $resolver,\n            resolverContext: resolverContext\n        });\n    }\n\n    /**\n     * @inheritdoc IRegistry\n     */\n    function deployViaFactory(\n        address factory,\n        bytes calldata callOnFactory,\n        bytes calldata metadata,\n        ResolverUID resolverUID,\n        bytes calldata resolverContext\n    )\n        external\n        payable\n        returns (address moduleAddress)\n    {\n        ResolverRecord storage $resolver = $resolvers[resolverUID];\n        if ($resolver.resolverOwner == ZERO_ADDRESS) revert InvalidResolverUID(resolverUID);\n\n        // prevent someone from calling a registry function pretending its a factory\n        if (factory == address(this)) revert FactoryCallFailed(factory);\n\n        // Call the factory via the trampoline contract. This will make sure that there is msg.sender separation\n        // Making \"raw\" calls to user supplied addresses could create security issues.\n        moduleAddress = FACTORY_TRAMPOLINE.deployViaFactory{ value: msg.value }({ factory: factory, callOnFactory: callOnFactory });\n\n        ModuleRecord memory record = _storeModuleRecord({\n            moduleAddress: moduleAddress,\n            sender: ZERO_ADDRESS, // setting sender to address(0) since anyone can invoke this function\n            resolverUID: resolverUID,\n            metadata: metadata\n        });\n\n        record.requireExternalResolverOnModuleRegistration({\n            moduleAddress: moduleAddress,\n            $resolver: $resolver,\n            resolverContext: resolverContext\n        });\n    }\n\n    /**\n     * Turns module registration artifacts to `ModuleRecord` to stores it in the registry storage\n     * @dev if a non-existent resolverUID is provided, this function reverts.\n     * @dev if moduleAddress is already registered, this function reverts.\n     * @dev if moduleAddress is not a contract, this function reverts.\n     * @param moduleAddress the address of the module to register\n     * @param sender the address of the sender who deployed the module\n     * @param resolverUID the unique identifier of the resolver\n     * @param metadata additional data related to the contract deployment.\n     *            This parameter is optional and may be used to facilitate custom business logic on the external resolver\n     */\n    function _storeModuleRecord(\n        address moduleAddress,\n        address sender,\n        ResolverUID resolverUID,\n        bytes calldata metadata\n    )\n        internal\n        returns (ModuleRecord memory moduleRegistration)\n    {\n        // ensure moduleAddress is not already registered\n        if ($moduleAddrToRecords[moduleAddress].resolverUID != EMPTY_RESOLVER_UID) {\n            revert AlreadyRegistered(moduleAddress);\n        }\n        // revert if moduleAddress is NOT a contract\n        // this should catch address(0)\n        if (!_isContract(moduleAddress)) revert InvalidDeployment();\n\n        // Store module metadata in _modules mapping\n        moduleRegistration = ModuleRecord({ resolverUID: resolverUID, sender: sender, metadata: metadata });\n\n        // Store module record in _modules mapping\n        $moduleAddrToRecords[moduleAddress] = moduleRegistration;\n\n        // Emit ModuleRegistration event\n        emit ModuleRegistration({ implementation: moduleAddress });\n    }\n\n    /**\n     * @inheritdoc IRegistry\n     */\n    function findModule(address moduleAddress) external view returns (ModuleRecord memory moduleRecord) {\n        return $moduleAddrToRecords[moduleAddress];\n    }\n}\n"},"src/core/TrustManagerExternalAttesterList.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.24;\n\nimport { AttestationRecord, ModuleType } from \"../DataTypes.sol\";\nimport { ZERO_MODULE_TYPE } from \"../Common.sol\";\n// solhint-disable-next-line no-unused-import\nimport { IRegistry, IERC7484 } from \"../IRegistry.sol\";\nimport { TrustManager } from \"./TrustManager.sol\";\nimport { TrustLib } from \"../lib/TrustLib.sol\";\n\n/**\n * If smart accounts want to query the registry, and supply a list of trusted attesters in calldata, this component can be used\n * @dev This contract is abstract and provides utility functions to query attestations with a calldata provided list of attesters\n *\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\n */\nabstract contract TrustManagerExternalAttesterList is IRegistry, TrustManager {\n    using TrustLib for AttestationRecord;\n\n    /**\n     * @inheritdoc IERC7484\n     */\n    function check(address module, address[] calldata attesters, uint256 threshold) external view {\n        uint256 attestersLength = attesters.length;\n        if (attestersLength == 0 || threshold == 0) {\n            revert NoTrustedAttestersFound();\n        } else if (attestersLength < threshold) {\n            revert InsufficientAttestations();\n        }\n\n        address _attesterCache;\n        for (uint256 i; i < attestersLength; ++i) {\n            address attester = attesters[i];\n            if (attester <= _attesterCache) revert InvalidTrustedAttesterInput();\n            else _attesterCache = attester;\n            if ($getAttestation(module, attester).checkValid(ZERO_MODULE_TYPE)) {\n                --threshold;\n            }\n            if (threshold == 0) return;\n        }\n        revert InsufficientAttestations();\n    }\n\n    /**\n     * @inheritdoc IERC7484\n     */\n    function check(address module, ModuleType moduleType, address[] calldata attesters, uint256 threshold) external view {\n        uint256 attestersLength = attesters.length;\n        if (attestersLength == 0 || threshold == 0) {\n            revert NoTrustedAttestersFound();\n        } else if (attestersLength < threshold) {\n            revert InsufficientAttestations();\n        }\n\n        address _attesterCache;\n        for (uint256 i; i < attestersLength; ++i) {\n            address attester = attesters[i];\n\n            if (attester <= _attesterCache) revert InvalidTrustedAttesterInput();\n            else _attesterCache = attester;\n            if ($getAttestation(module, attester).checkValid(moduleType)) {\n                --threshold;\n            }\n            if (threshold == 0) return;\n        }\n        revert InsufficientAttestations();\n    }\n}\n"},"src/lib/StubLib.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.24;\n\nimport { AttestationRecord, ResolverRecord, SchemaRecord, ModuleRecord } from \"../DataTypes.sol\";\nimport { IExternalSchemaValidator } from \"../external/IExternalSchemaValidator.sol\";\nimport { IExternalResolver } from \"../external/IExternalResolver.sol\";\nimport { ZERO_ADDRESS, ZERO_TIMESTAMP } from \"../Common.sol\";\nimport { IRegistry } from \"../IRegistry.sol\";\n\n/**\n * Helper library for interacting with `IExternalResolver` and `IExternalSchemaValidator`\n * @dev if a certain resolver or validator is not set, the function will return without reverting\n */\nlibrary StubLib {\n    event ResolverRevocationError(IExternalResolver resolver);\n\n    /**\n     * Calls an external schema validator contract to validate the schema for a single attestation\n     * @dev if Schema Validator is set, it will call `validateSchema()` on the `IExternalSchemaValidator` contract\n     * @param attestationRecord the data record that will be written into registry for this attestation\n     * @param $schema the storage reference of the schema record\n     */\n    function requireExternalSchemaValidation(AttestationRecord memory attestationRecord, SchemaRecord storage $schema) internal {\n        // only run this function if the selected schemaUID exists\n        if ($schema.registeredAt == ZERO_TIMESTAMP) revert IRegistry.InvalidSchema();\n        // validate Schema\n        IExternalSchemaValidator validator = $schema.validator;\n        // if validator is set, call the validator\n        if (address(validator) != ZERO_ADDRESS && validator.validateSchema(attestationRecord) == false) {\n            revert IRegistry.ExternalError_SchemaValidation();\n        }\n    }\n\n    /**\n     * Calls an external schema validator contract to validate the schema for multiple attestation\n     * @dev if Schema Validator is set, it will call `validateSchema()` on the `IExternalSchemaValidator` contract\n     * @param attestationRecords the data records that will be written into registry for the attestations\n     * @param $schema the storage reference of the schema record\n     */\n    function requireExternalSchemaValidation(AttestationRecord[] memory attestationRecords, SchemaRecord storage $schema) internal {\n        // only run this function if the selected schemaUID exists\n        if ($schema.registeredAt == ZERO_TIMESTAMP) revert IRegistry.InvalidSchema();\n        // validate Schema\n        IExternalSchemaValidator validator = $schema.validator;\n        // if validator is set, call the validator\n        if (address(validator) != ZERO_ADDRESS && validator.validateSchema(attestationRecords) == false) {\n            revert IRegistry.ExternalError_SchemaValidation();\n        }\n    }\n\n    /**\n     * Calls an external resolver contract to resolve a single attestation\n     * @dev if a resolver is set, it will call `resolveAttestation()` on the `IExternalResolver` contract\n     * @param attestationRecord the data record that will be written into registry for the attestation\n     * @param $resolver the storage reference of the resolver record used for this attestation\n     */\n    function requireExternalResolverOnAttestation(AttestationRecord memory attestationRecord, ResolverRecord storage $resolver) internal {\n        IExternalResolver resolverContract = $resolver.resolver;\n\n        if (address(resolverContract) != ZERO_ADDRESS && resolverContract.resolveAttestation(attestationRecord) == false) {\n            revert IRegistry.ExternalError_ResolveAttestation();\n        }\n    }\n\n    /**\n     * Calls an external resolver contract to resolve multiple attestations\n     * @dev if a resolver is set, it will call `resolveAttestation()` on the `IExternalResolver` contract\n     * @param attestationRecords the data records that will be written into registry for the attestation\n     * @param $resolver the storage reference of the resolver record used for this attestation\n     */\n    function requireExternalResolverOnAttestation(\n        AttestationRecord[] memory attestationRecords,\n        ResolverRecord storage $resolver\n    )\n        internal\n    {\n        IExternalResolver resolverContract = $resolver.resolver;\n\n        if (address(resolverContract) == ZERO_ADDRESS) return;\n\n        if (resolverContract.resolveAttestation(attestationRecords) == false) {\n            revert IRegistry.ExternalError_ResolveAttestation();\n        }\n    }\n\n    /**\n     * Calls an external resolver contract to resolve a single revocation\n     * @dev if a resolver is set, it will call `resolveRevocation()` on the `IExternalResolver` contract\n     * @dev if the resolver contract reverts, the function will return without reverting.\n     * This prevents Resolvers from denying revocations\n     * @param attestationRecord the data records of the attestation that will be revoked\n     * @param $resolver the storage reference of the resolver record used for this attestation\n     */\n    function tryExternalResolverOnRevocation(\n        AttestationRecord memory attestationRecord,\n        ResolverRecord storage $resolver\n    )\n        internal\n        returns (bool resolved)\n    {\n        IExternalResolver resolverContract = $resolver.resolver;\n\n        if (address(resolverContract) == ZERO_ADDRESS) return true;\n        try resolverContract.resolveRevocation(attestationRecord) returns (bool _resolved) {\n            if (_resolved) return true;\n        } catch {\n            emit ResolverRevocationError(resolverContract);\n            return false;\n        }\n    }\n\n    /**\n     * Calls an external resolver contract to resolve multiple revocation\n     * @dev if a resolver is set, it will call `resolveRevocation()` on the `IExternalResolver` contract\n     * @dev if the resolver contract reverts, the function will return without reverting.\n     * This prevents Resolvers to stop DoS revocations\n     * @param attestationRecords the data records of the attestations that will be revoked\n     * @param $resolver the storage reference of the resolver record used for this attestation\n     */\n    function tryExternalResolverOnRevocation(\n        AttestationRecord[] memory attestationRecords,\n        ResolverRecord storage $resolver\n    )\n        internal\n        returns (bool resolved)\n    {\n        IExternalResolver resolverContract = $resolver.resolver;\n\n        if (address(resolverContract) == ZERO_ADDRESS) return true;\n        try resolverContract.resolveRevocation(attestationRecords) returns (bool _resolved) {\n            if (_resolved) return true;\n        } catch {\n            emit ResolverRevocationError(resolverContract);\n            return false;\n        }\n    }\n\n    /**\n     * Calls an external resolver contract to resolve a module registration\n     * @dev if a resolver is set, it will call `resolveModuleRegistration()` on the `IExternalResolver` contract\n     * @param moduleRecord the module record that will be written into registry for the module registration\n     * @param moduleAddress the address of the module to register.\n     *       at the point of this call, the module MUST be already deployed (could be within the current transaction)\n     * @param $resolver the storage reference of the resolver record used for this module registration\n     */\n    function requireExternalResolverOnModuleRegistration(\n        ModuleRecord memory moduleRecord,\n        address moduleAddress,\n        ResolverRecord storage $resolver,\n        bytes calldata resolverContext\n    )\n        internal\n    {\n        IExternalResolver resolverContract = $resolver.resolver;\n\n        if (\n            address(resolverContract) != ZERO_ADDRESS\n                && resolverContract.resolveModuleRegistration({\n                    sender: msg.sender,\n                    moduleAddress: moduleAddress,\n                    record: moduleRecord,\n                    resolverContext: resolverContext\n                }) == false\n        ) {\n            revert IRegistry.ExternalError_ModuleRegistration();\n        }\n    }\n}\n"},"src/lib/ModuleTypeLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport { PackedModuleTypes, ModuleType } from \"../DataTypes.sol\";\nimport { IRegistry } from \"../IRegistry.sol\";\n\nlibrary ModuleTypeLib {\n    function isType(PackedModuleTypes self, ModuleType moduleType) internal pure returns (bool) {\n        return (PackedModuleTypes.unwrap(self) & 2 ** ModuleType.unwrap(moduleType)) != 0;\n    }\n\n    function isType(uint32 packed, uint256 check) internal pure returns (bool) {\n        return (packed & 2 ** check) != 0;\n    }\n\n    function pack(ModuleType[] memory moduleTypes) internal pure returns (PackedModuleTypes) {\n        uint256 length = moduleTypes.length;\n        uint32 packed;\n        uint256 _type;\n        for (uint256 i; i < length; i++) {\n            _type = ModuleType.unwrap(moduleTypes[i]);\n            if (_type > 31 || isType(packed, _type)) revert IRegistry.InvalidModuleType();\n            packed = packed + uint32(2 ** _type);\n        }\n        return PackedModuleTypes.wrap(packed);\n    }\n}\n"},"src/Common.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.24;\n\nimport { ResolverUID, SchemaUID, AttestationDataRef, ModuleType } from \"./DataTypes.sol\";\n\n// A representation of an empty/uninitialized UID.\nbytes32 constant EMPTY_UID = 0;\nResolverUID constant EMPTY_RESOLVER_UID = ResolverUID.wrap(EMPTY_UID);\nSchemaUID constant EMPTY_SCHEMA_UID = SchemaUID.wrap(EMPTY_UID);\n\n// A zero expiration represents an non-expiring attestation.\nuint256 constant ZERO_TIMESTAMP = 0;\n\naddress constant ZERO_ADDRESS = address(0);\nModuleType constant ZERO_MODULE_TYPE = ModuleType.wrap(0);\n\nAttestationDataRef constant EMPTY_ATTESTATION_REF = AttestationDataRef.wrap(address(0));\n\n/**\n * @dev Returns the current's block timestamp. This method is overridden during tests and used to simulate the\n * current block time.\n */\nfunction _time() view returns (uint48) {\n    return uint48(block.timestamp);\n}\n\n/**\n * @dev Returns whether an address is a contract.\n * @param addr The address to check.\n *\n * @return true if `account` is a contract, false otherwise.\n */\nfunction _isContract(address addr) view returns (bool) {\n    return addr.code.length > 0;\n}\n"},"src/lib/Helpers.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.24;\n\nimport { ResolverRecord, SchemaRecord, SchemaUID, ResolverUID } from \"../DataTypes.sol\";\n\nlibrary UIDLib {\n    /**\n     * @dev Calculates a UID for a given schema.\n     *\n     * @param schemaRecord The input schema.\n     *\n     * @return schema UID.\n     */\n    function getUID(SchemaRecord memory schemaRecord) internal view returns (SchemaUID) {\n        return SchemaUID.wrap(keccak256(abi.encodePacked(msg.sender, schemaRecord.schema, address(schemaRecord.validator))));\n    }\n\n    /**\n     * @dev Calculates a UID for a given resolver.\n     *\n     * @param resolver The input schema.\n     *\n     * @return ResolverUID.\n     */\n    function getUID(ResolverRecord memory resolver) internal view returns (ResolverUID) {\n        return ResolverUID.wrap(keccak256(abi.encodePacked(msg.sender, resolver.resolver)));\n    }\n}\n"},"src/lib/ModuleDeploymentLib.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.24;\n\n/**\n * @title ModuleDeploymentLib\n * @dev A library that can be used to deploy the Registry\n * @author zeroknots\n */\nlibrary ModuleDeploymentLib {\n    error InvalidSalt();\n    error InvalidAddress();\n    // source: https://github.com/0age/metamorphic/blob/master/contracts/ImmutableCreate2Factory.sol#L194-L203\n\n    modifier containsCaller(bytes32 salt) {\n        // prevent contract submissions from being stolen from tx.pool by requiring\n        // that the first 20 bytes of the submitted salt match msg.sender.\n        if ((address(bytes20(salt)) != msg.sender) && (bytes20(salt) != bytes20(0))) revert InvalidSalt();\n        _;\n    }\n\n    function deploy(bytes calldata _initCode, bytes32 salt) internal containsCaller(salt) returns (address deploymentAddress) {\n        // move the initialization code from calldata to memory.\n        bytes memory initCode = _initCode;\n\n        // determine the target address for contract deployment.\n        address targetDeploymentAddress = calcAddress(_initCode, salt);\n\n        // using inline assembly: load data and length of data, then call CREATE2.\n        assembly {\n            let encoded_data := add(0x20, initCode) // load initialization code.\n            let encoded_size := mload(initCode) // load the init code's length.\n            deploymentAddress :=\n                create2( // call CREATE2 with 4 arguments.\n                    callvalue(), // forward any attached value.\n                    encoded_data, // pass in initialization code.\n                    encoded_size, // pass in init code's length.\n                    salt // pass in the salt value.\n                )\n        }\n\n        // check address against target to ensure that deployment was successful.\n        if (deploymentAddress != targetDeploymentAddress) revert InvalidAddress();\n    }\n\n    /**\n     * @notice Calculates the deterministic address of a contract that would be deployed using the CREATE2 opcode.\n     * @dev The calculated address is based on the contract's code, a salt, and the address of the current contract.\n     * @dev This function uses the formula specified in EIP-1014 (https://eips.ethereum.org/EIPS/eip-1014).\n     *\n     * @param initCode The contract code that would be deployed.\n     * @param salt A salt used for the address calculation.\n     *                 This must be the same salt that would be passed to the CREATE2 opcode.\n     *\n     * @return targetDeploymentAddress The address that the contract would be deployed\n     *            at if the CREATE2 opcode was called with the specified _code and _salt.\n     */\n    function calcAddress(bytes calldata initCode, bytes32 salt) internal view returns (address targetDeploymentAddress) {\n        targetDeploymentAddress = address(\n            uint160( // downcast to match the address type.\n                uint256( // convert to uint to truncate upper digits.\n                    keccak256( // compute the CREATE2 hash using 4 inputs.\n                        abi.encodePacked( // pack all inputs to the hash together.\n                            hex\"ff\", // start with 0xff to distinguish from RLP.\n                            address(this), // this contract will be the caller.\n                            salt, // pass in the supplied salt value.\n                            keccak256( // pass in the hash of initialization code.\n                            abi.encodePacked(initCode))\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    error InvalidDeployment();\n}\n"},"src/core/ResolverManager.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.24;\n\nimport { ResolverRecord, ResolverUID } from \"../DataTypes.sol\";\nimport { ZERO_ADDRESS } from \"../Common.sol\";\nimport { IExternalResolver } from \"../external/IExternalResolver.sol\";\nimport { UIDLib } from \"../lib/Helpers.sol\";\nimport { IRegistry } from \"../IRegistry.sol\";\n\n/**\n * Resolvers are external contracts that are tied to Modules and called when specific Registry actions are executed.\n * ## Resolver Hooks\n *\n * external Resolvers are called during:\n *\n * - attestation\n * - revocation\n * - module registration\n *\n * This architectural design aims to provide entities like Smart Account vendors or DAOs, with the\n * flexibility to incorporate custom business logic while maintaining the\n * robustness and security of the core functionalities implemented by the Registry.\n *\n * ## Role of Resolvers in extending Registry functionalities\n *\n * Entities utilizing the Registry frequently need to extend its core functionalities\n * to cater to their unique business requirements. Resolvers are the mechanisms that\n * make this possible, allowing for:\n *\n * - _Custom Business Logic Integration:_ Entities can build upon the foundational\n *   registry operations by introducing complex logic sequences, tailored to their\n *   operational needs.\n *\n * - _Security Assurance:_ One of the significant advantages of using resolvers is that\n *   they abstract away the intricacies of attestation storage and validation.\n *   This abstraction ensures that the foundational security of the Registry isn't compromised,\n *   even when new functionalities are added.\n *\n * - _Cost Efficiency in Audits:_ Given that the core attestation storage and validation\n *   logic remains untouched, auditing becomes more straightforward and cost-effective.\n *   Entities can focus their audit efforts on their custom logic without the need to\n *   re-audit the underlying core systems.\n *\n * ## The `IExternalResolver` interface: Standardizing Resolvers\n *\n * For any entity looking to employ a resolver, adherence to a standardized\n * interface is essential.\n * The [IExternalResolver interface](../../external/IExternalResolver.sol/interface.IExternalResolver.html) delineates the essential\n * functions a resolver must implement to ensure seamless integration and operation with the Registry.\n * @dev only `msg.sender` and the external `IExternalResolver` address are used to create a unique ID for the resolver\n *    This allows for a single resolver address to be possible across different chains\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\n */\nabstract contract ResolverManager is IRegistry {\n    using UIDLib for ResolverRecord;\n\n    mapping(ResolverUID uid => ResolverRecord resolver) internal $resolvers;\n\n    /**\n     * @dev Modifier to require that the caller is the owner of a resolver\n     *\n     * @param uid The UID of the resolver.\n     */\n    modifier onlyResolverOwner(ResolverUID uid) {\n        if ($resolvers[uid].resolverOwner != msg.sender) {\n            revert AccessDenied();\n        }\n        _;\n    }\n\n    /**\n     * If a resolver is not address(0), we check if it supports the `IExternalResolver` interface\n     */\n    modifier onlyResolver(IExternalResolver resolver) {\n        if (address(resolver) == address(0) || !resolver.supportsInterface(type(IExternalResolver).interfaceId)) {\n            revert InvalidResolver(resolver);\n        }\n        _;\n    }\n\n    /**\n     * @inheritdoc IRegistry\n     */\n    function registerResolver(IExternalResolver resolver) external onlyResolver(resolver) returns (ResolverUID uid) {\n        // build a ResolverRecord from the input\n        ResolverRecord memory resolverRecord = ResolverRecord({ resolver: resolver, resolverOwner: msg.sender });\n\n        // Computing a unique ID for the schema using its properties\n        uid = resolverRecord.getUID();\n\n        // Checking if a schema with this UID already exists -> resolver can never be ZERO_ADDRESS\n        if (address($resolvers[uid].resolver) != ZERO_ADDRESS) {\n            revert ResolverAlreadyExists();\n        }\n\n        // SSTORE schema in the resolvers mapping\n        $resolvers[uid] = resolverRecord;\n\n        emit NewResolver(uid, address(resolver));\n    }\n\n    /**\n     * @inheritdoc IRegistry\n     */\n    function setResolver(\n        ResolverUID uid,\n        IExternalResolver resolver\n    )\n        external\n        onlyResolver(resolver)\n        onlyResolverOwner(uid) // authorization control\n    {\n        ResolverRecord storage referrer = $resolvers[uid];\n        referrer.resolver = resolver;\n        emit NewResolver(uid, address(resolver));\n    }\n\n    /**\n     * @inheritdoc IRegistry\n     */\n    function transferResolverOwnership(ResolverUID uid, address newOwner) external onlyResolverOwner(uid) {\n        $resolvers[uid].resolverOwner = newOwner;\n        emit NewResolverOwner(uid, newOwner);\n    }\n\n    /**\n     * @inheritdoc IRegistry\n     */\n    function findResolver(ResolverUID uid) external view returns (ResolverRecord memory) {\n        return $resolvers[uid];\n    }\n}\n"},"src/core/TrustManager.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.24;\n\nimport { AttestationRecord, PackedModuleTypes, ModuleType, TrustedAttesterRecord } from \"../DataTypes.sol\";\nimport { ZERO_MODULE_TYPE, ZERO_ADDRESS } from \"../Common.sol\";\n// solhint-disable-next-line no-unused-import\nimport { IRegistry, IERC7484 } from \"../IRegistry.sol\";\nimport { ModuleTypeLib } from \"../lib/ModuleTypeLib.sol\";\nimport { TrustLib } from \"../lib/TrustLib.sol\";\nimport { LibSort } from \"solady/utils/LibSort.sol\";\n\n/**\n * Allows smart accounts to query the registry for the security status of modules.\n * Smart accounts may trust a list of attesters to attest to the security status of\n *   modules and configure a minimum threshold of how many attestations have to be in place\n *   to consider a module as \"trust worthy\"\n * Implements `ERC-7484` to query attestations stored in the registry.\n * @dev This contract is abstract and provides utility functions to query attestations.\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\n */\nabstract contract TrustManager is IRegistry {\n    using ModuleTypeLib for PackedModuleTypes;\n    using TrustLib for AttestationRecord;\n    using LibSort for address[];\n\n    error InvalidThreshold();\n\n    mapping(address account => TrustedAttesterRecord attesters) internal $accountToAttester;\n\n    /**\n     * @inheritdoc IERC7484\n     */\n    function trustAttesters(uint8 threshold, address[] calldata attesters) external {\n        uint256 attestersLength = attesters.length;\n\n        if (!attesters.isSortedAndUniquified()) revert InvalidTrustedAttesterInput();\n\n        // if attesters array has duplicates or is too large revert\n        if (attestersLength == 0 || attestersLength > type(uint8).max) revert InvalidTrustedAttesterInput();\n        if (attesters.length != attestersLength) revert InvalidTrustedAttesterInput();\n        // revert if the first attester is the zero address\n        // other attesters can not be zero address, as the array was sorted\n        if (attesters[0] == ZERO_ADDRESS) revert InvalidTrustedAttesterInput();\n\n        TrustedAttesterRecord storage $trustedAttester = $accountToAttester[msg.sender];\n\n        // threshold cannot be greater than the number of attesters\n        if (threshold > attestersLength) {\n            revert InvalidThreshold();\n        }\n\n        $trustedAttester.attesterCount = uint8(attestersLength);\n        $trustedAttester.threshold = threshold;\n        $trustedAttester.attester = attesters[0];\n\n        attestersLength--;\n\n        // setup the linked list of trusted attesters\n        for (uint256 i; i < attestersLength; i++) {\n            address _attester = attesters[i];\n            $trustedAttester.linkedAttesters[_attester][msg.sender] = attesters[i + 1];\n        }\n\n        emit NewTrustedAttesters(msg.sender);\n    }\n\n    /**\n     * @inheritdoc IERC7484\n     */\n    function check(address module) external view {\n        _check(msg.sender, module, ZERO_MODULE_TYPE);\n    }\n\n    /**\n     * @inheritdoc IERC7484\n     */\n    function checkForAccount(address smartAccount, address module) external view {\n        _check(smartAccount, module, ZERO_MODULE_TYPE);\n    }\n\n    /**\n     * @inheritdoc IERC7484\n     */\n    function check(address module, ModuleType moduleType) external view {\n        _check(msg.sender, module, moduleType);\n    }\n\n    /**\n     * @inheritdoc IERC7484\n     */\n    function checkForAccount(address smartAccount, address module, ModuleType moduleType) external view {\n        _check(smartAccount, module, moduleType);\n    }\n\n    /**\n     * Internal helper function to check for module's security attestations on behalf of a Smart Account\n     * will use registry's storage to get the trusted attester(s) of a smart account, and check if the module was attested\n     * @param smartAccount the smart account to check for\n     * @param module address of the module to check\n     * @param moduleType (optional param), setting  moduleType = 0, will ignore moduleTypes in attestations\n     */\n    function _check(address smartAccount, address module, ModuleType moduleType) internal view {\n        TrustedAttesterRecord storage $trustedAttesters = $accountToAttester[smartAccount];\n\n        // SLOAD from one slot\n        uint256 attesterCount = $trustedAttesters.attesterCount;\n        uint256 threshold = $trustedAttesters.threshold;\n        address attester = $trustedAttesters.attester;\n\n        // smart account has no trusted attesters set\n        if (attester == ZERO_ADDRESS || threshold == 0) {\n            revert NoTrustedAttestersFound();\n        }\n        // smart account only has ONE trusted attester\n        // use this condition to save gas\n        else if (threshold == 1) {\n            AttestationRecord storage $attestation = $getAttestation({ module: module, attester: attester });\n            if ($attestation.checkValid(moduleType)) return;\n\n            // if first attestation is not valid, iterate over the linked list of attesters\n            // and check if the attestation is valid\n            for (uint256 i; i < attesterCount; i++) {\n                attester = $trustedAttesters.linkedAttesters[attester][smartAccount];\n                $attestation = $getAttestation({ module: module, attester: attester });\n                if ($attestation.checkValid(moduleType)) return;\n            }\n            // if no valid attestations were found in the for loop. the module is not valid\n            revert InsufficientAttestations();\n        }\n        // smart account has more than one trusted attester\n        else {\n            // loop though list and check if the attestation is valid\n            AttestationRecord storage $attestation = $getAttestation({ module: module, attester: attester });\n            if ($attestation.checkValid(moduleType)) threshold--;\n\n            for (uint256 i = 1; i < attesterCount; i++) {\n                // get next attester from linked List\n                attester = $trustedAttesters.linkedAttesters[attester][smartAccount];\n                $attestation = $getAttestation({ module: module, attester: attester });\n                if ($attestation.checkValid(moduleType)) threshold--;\n\n                // if threshold reached, exit loop\n                if (threshold == 0) return;\n            }\n            if (threshold > 0) revert InsufficientAttestations();\n        }\n    }\n\n    /**\n     * @inheritdoc IRegistry\n     */\n    function findTrustedAttesters(address smartAccount) public view returns (address[] memory attesters) {\n        TrustedAttesterRecord storage $trustedAttesters = $accountToAttester[smartAccount];\n\n        uint256 count = $trustedAttesters.attesterCount;\n        address attester0 = $trustedAttesters.attester;\n\n        // return if no trusted attesters are set\n        if (count == 0) return attesters;\n\n        attesters = new address[](count);\n        attesters[0] = attester0;\n\n        for (uint256 i = 1; i < count; i++) {\n            // get next attester from linked List\n            attesters[i] = $trustedAttesters.linkedAttesters[attesters[i - 1]][smartAccount];\n        }\n    }\n\n    function $getAttestation(address module, address attester) internal view virtual returns (AttestationRecord storage $attestation);\n}\n"},"src/lib/TrustLib.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.24;\n\nimport { AttestationRecord, PackedModuleTypes, ModuleType } from \"../DataTypes.sol\";\nimport { ZERO_TIMESTAMP, ZERO_MODULE_TYPE } from \"../Common.sol\";\nimport { IRegistry } from \"../IRegistry.sol\";\nimport { ModuleTypeLib } from \"../lib/ModuleTypeLib.sol\";\n\n/**\n * Library implements checks to validate if a storage reference for an `AttestationRecord` is currently valid\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\n */\nlibrary TrustLib {\n    using ModuleTypeLib for PackedModuleTypes;\n\n    /**\n     * Check that attestationRecord is valid:\n     *                 - not revoked\n     *                 - not expired\n     *                 - correct module type (if not ZERO_MODULE_TYPE)\n     * @notice this function reverts if the attestationRecord is not valid\n     * @param expectedType the expected module type. if this is ZERO_MODULE_TYPE, types specified in the attestation are ignored\n     * @param $attestation the storage reference of the attestation record to check\n     */\n    function enforceValid(AttestationRecord storage $attestation, ModuleType expectedType) internal view {\n        uint256 attestedAt;\n        uint256 expirationTime;\n        uint256 revocationTime;\n        PackedModuleTypes packedModuleType;\n\n        /*\n         * Ensure only one SLOAD\n         * Assembly equiv to:\n         *\n         *     uint256 attestedAt = record.time;\n         *     uint256 expirationTime = record.expirationTime;\n         *     uint256 revocationTime = record.revocationTime;\n         *     PackedModuleTypes packedModuleType = record.moduleTypes;\n         */\n        assembly {\n            let mask := 0xFFFFFFFF\n            let slot := sload($attestation.slot)\n            attestedAt := and(mask, slot)\n            slot := shr(48, slot)\n            expirationTime := and(mask, slot)\n            slot := shr(48, slot)\n            revocationTime := and(mask, slot)\n            slot := shr(48, slot)\n            packedModuleType := and(mask, slot)\n        }\n\n        // check if any attestation was made\n        if (attestedAt == ZERO_TIMESTAMP) {\n            revert IRegistry.AttestationNotFound();\n        }\n\n        // check if attestation has expired\n        if (expirationTime != ZERO_TIMESTAMP && block.timestamp > expirationTime) {\n            revert IRegistry.AttestationNotFound();\n        }\n\n        // check if attestation has been revoked\n        if (revocationTime != ZERO_TIMESTAMP) {\n            revert IRegistry.RevokedAttestation($attestation.attester);\n        }\n\n        // if a expectedType is set, check if the attestation is for the correct module type\n        // if no expectedType is set, module type is not checked\n        if (expectedType != ZERO_MODULE_TYPE && !packedModuleType.isType(expectedType)) {\n            revert IRegistry.InvalidModuleType();\n        }\n    }\n\n    /**\n     * Check that attestationRecord is valid:\n     *                 - not revoked\n     *                 - not expired\n     *                 - correct module type (if not ZERO_MODULE_TYPE)\n     * @dev this function DOES NOT revert if the attestationRecord is not valid, but returns false\n     * @param expectedType the expected module type. if this is ZERO_MODULE_TYPE, types specified in the attestation are ignored\n     * @param $attestation the storage reference of the attestation record to check\n     */\n    function checkValid(AttestationRecord storage $attestation, ModuleType expectedType) internal view returns (bool) {\n        uint256 attestedAt;\n        uint256 expirationTime;\n        uint256 revocationTime;\n        PackedModuleTypes packedModuleType;\n\n        /*\n         * Ensure only one SLOAD\n         * Assembly equiv to:\n         *\n         *     uint256 attestedAt = record.time;\n         *     uint256 expirationTime = record.expirationTime;\n         *     uint256 revocationTime = record.revocationTime;\n         *     PackedModuleTypes packedModuleType = record.moduleTypes;\n         */\n        assembly {\n            let mask := 0xFFFFFFFF\n            let slot := sload($attestation.slot)\n            attestedAt := and(mask, slot)\n            slot := shr(48, slot)\n            expirationTime := and(mask, slot)\n            slot := shr(48, slot)\n            revocationTime := and(mask, slot)\n            slot := shr(48, slot)\n            packedModuleType := and(mask, slot)\n        }\n\n        // check if any attestation was made\n        if (attestedAt == ZERO_TIMESTAMP) {\n            return false;\n        }\n\n        // check if attestation has expired\n        if (expirationTime != ZERO_TIMESTAMP && block.timestamp > expirationTime) {\n            return false;\n        }\n\n        // check if attestation has been revoked\n        if (revocationTime != ZERO_TIMESTAMP) {\n            return false;\n        }\n        // if a expectedType is set, check if the attestation is for the correct module type\n        // if no expectedType is set, module type is not checked\n        if (expectedType != ZERO_MODULE_TYPE && !packedModuleType.isType(expectedType)) {\n            return false;\n        }\n        return true;\n    }\n}\n"},"node_modules/solady/src/utils/LibSort.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Optimized sorts and operations for sorted arrays.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Sort.sol)\nlibrary LibSort {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      INSERTION SORT                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // - Faster on small arrays (32 or lesser elements).\n    // - Faster on almost sorted arrays.\n    // - Smaller bytecode.\n    // - May be suitable for view functions intended for off-chain querying.\n\n    /// @dev Sorts the array in-place with insertion sort.\n    function insertionSort(uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(a) // Length of `a`.\n            mstore(a, 0) // For insertion sort's inner loop to terminate.\n            let h := add(a, shl(5, n)) // High slot.\n            let s := 0x20\n            let w := not(0x1f)\n            for { let i := add(a, s) } 1 {} {\n                i := add(i, s)\n                if gt(i, h) { break }\n                let k := mload(i) // Key.\n                let j := add(i, w) // The slot before the current slot.\n                let v := mload(j) // The value of `j`.\n                if iszero(gt(v, k)) { continue }\n                for {} 1 {} {\n                    mstore(add(j, s), v)\n                    j := add(j, w) // `sub(j, 0x20)`.\n                    v := mload(j)\n                    if iszero(gt(v, k)) { break }\n                }\n                mstore(add(j, s), k)\n            }\n            mstore(a, n) // Restore the length of `a`.\n        }\n    }\n\n    /// @dev Sorts the array in-place with insertion sort.\n    function insertionSort(int256[] memory a) internal pure {\n        _flipSign(a);\n        insertionSort(_toUints(a));\n        _flipSign(a);\n    }\n\n    /// @dev Sorts the array in-place with insertion sort.\n    function insertionSort(address[] memory a) internal pure {\n        insertionSort(_toUints(a));\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      INTRO-QUICKSORT                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // - Faster on larger arrays (more than 32 elements).\n    // - Robust performance.\n    // - Larger bytecode.\n\n    /// @dev Sorts the array in-place with intro-quicksort.\n    function sort(uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let s := 0x20\n            let n := mload(a) // Length of `a`.\n            mstore(a, 0) // For insertion sort's inner loop to terminate.\n\n            // Let the stack be the start of the free memory.\n            let stack := mload(0x40)\n\n            for {} iszero(lt(n, 2)) {} {\n                // Push `l` and `h` to the stack.\n                // The `shl` by 5 is equivalent to multiplying by `0x20`.\n                let l := add(a, s)\n                let h := add(a, shl(5, n))\n\n                let j := l\n                // forgefmt: disable-next-item\n                for {} iszero(or(eq(j, h), gt(mload(j), mload(add(j, s))))) {} {\n                    j := add(j, s)\n                }\n                // If the array is already sorted.\n                if eq(j, h) { break }\n\n                j := h\n                // forgefmt: disable-next-item\n                for {} iszero(gt(mload(j), mload(add(j, w)))) {} {\n                    j := add(j, w) // `sub(j, 0x20)`.\n                }\n                // If the array is reversed sorted.\n                if eq(j, l) {\n                    for {} 1 {} {\n                        let t := mload(l)\n                        mstore(l, mload(h))\n                        mstore(h, t)\n                        h := add(h, w) // `sub(h, 0x20)`.\n                        l := add(l, s)\n                        if iszero(lt(l, h)) { break }\n                    }\n                    break\n                }\n\n                // Push `l` and `h` onto the stack.\n                mstore(stack, l)\n                mstore(add(stack, s), h)\n                stack := add(stack, 0x40)\n                break\n            }\n\n            for { let stackBottom := mload(0x40) } iszero(eq(stack, stackBottom)) {} {\n                // Pop `l` and `h` from the stack.\n                stack := sub(stack, 0x40)\n                let l := mload(stack)\n                let h := mload(add(stack, s))\n\n                // Do insertion sort if `h - l <= 0x20 * 12`.\n                // Threshold is fine-tuned via trial and error.\n                if iszero(gt(sub(h, l), 0x180)) {\n                    // Hardcode sort the first 2 elements.\n                    let i := add(l, s)\n                    if iszero(lt(mload(l), mload(i))) {\n                        let t := mload(i)\n                        mstore(i, mload(l))\n                        mstore(l, t)\n                    }\n                    for {} 1 {} {\n                        i := add(i, s)\n                        if gt(i, h) { break }\n                        let k := mload(i) // Key.\n                        let j := add(i, w) // The slot before the current slot.\n                        let v := mload(j) // The value of `j`.\n                        if iszero(gt(v, k)) { continue }\n                        for {} 1 {} {\n                            mstore(add(j, s), v)\n                            j := add(j, w)\n                            v := mload(j)\n                            if iszero(gt(v, k)) { break }\n                        }\n                        mstore(add(j, s), k)\n                    }\n                    continue\n                }\n                // Pivot slot is the average of `l` and `h`.\n                let p := add(shl(5, shr(6, add(l, h))), and(31, l))\n                // Median of 3 with sorting.\n                {\n                    function swap(a_, b_) -> _b, _a {\n                        _b := a_\n                        _a := b_\n                    }\n                    let e0 := mload(l)\n                    let e1 := mload(h)\n                    if iszero(lt(e0, e1)) { e1, e0 := swap(e0, e1) }\n                    let e2 := mload(p)\n                    if iszero(lt(e2, e1)) { e2, e1 := swap(e1, e2) }\n                    if iszero(lt(e0, e2)) { e2, e0 := swap(e0, e2) }\n                    mstore(p, e2)\n                    mstore(h, e1)\n                    mstore(l, e0)\n                }\n                // Hoare's partition.\n                {\n                    // The value of the pivot slot.\n                    let x := mload(p)\n                    p := h\n                    for { let i := l } 1 {} {\n                        for {} 1 {} {\n                            i := add(i, s)\n                            if iszero(gt(x, mload(i))) { break }\n                        }\n                        let j := p\n                        for {} 1 {} {\n                            j := add(j, w)\n                            if iszero(lt(x, mload(j))) { break }\n                        }\n                        p := j\n                        if iszero(lt(i, p)) { break }\n                        // Swap slots `i` and `p`.\n                        let t := mload(i)\n                        mstore(i, mload(p))\n                        mstore(p, t)\n                    }\n                }\n                // If slice on right of pivot is non-empty, push onto stack.\n                {\n                    mstore(stack, add(p, s))\n                    // Skip `mstore(add(stack, 0x20), h)`, as it is already on the stack.\n                    stack := add(stack, shl(6, lt(add(p, s), h)))\n                }\n                // If slice on left of pivot is non-empty, push onto stack.\n                {\n                    mstore(stack, l)\n                    mstore(add(stack, s), p)\n                    stack := add(stack, shl(6, gt(p, l)))\n                }\n            }\n            mstore(a, n) // Restore the length of `a`.\n        }\n    }\n\n    /// @dev Sorts the array in-place with intro-quicksort.\n    function sort(int256[] memory a) internal pure {\n        _flipSign(a);\n        sort(_toUints(a));\n        _flipSign(a);\n    }\n\n    /// @dev Sorts the array in-place with intro-quicksort.\n    function sort(address[] memory a) internal pure {\n        sort(_toUints(a));\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  OTHER USEFUL OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // For performance, the `uniquifySorted` methods will not revert if the\n    // array is not sorted -- it will simply remove consecutive duplicate elements.\n\n    /// @dev Removes duplicate elements from a ascendingly sorted memory array.\n    function uniquifySorted(uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the length of `a` is greater than 1.\n            if iszero(lt(mload(a), 2)) {\n                let x := add(a, 0x20)\n                let y := add(a, 0x40)\n                let end := add(a, shl(5, add(mload(a), 1)))\n                for {} 1 {} {\n                    if iszero(eq(mload(x), mload(y))) {\n                        x := add(x, 0x20)\n                        mstore(x, mload(y))\n                    }\n                    y := add(y, 0x20)\n                    if eq(y, end) { break }\n                }\n                mstore(a, shr(5, sub(x, a)))\n            }\n        }\n    }\n\n    /// @dev Removes duplicate elements from a ascendingly sorted memory array.\n    function uniquifySorted(int256[] memory a) internal pure {\n        uniquifySorted(_toUints(a));\n    }\n\n    /// @dev Removes duplicate elements from a ascendingly sorted memory array.\n    function uniquifySorted(address[] memory a) internal pure {\n        uniquifySorted(_toUints(a));\n    }\n\n    /// @dev Returns whether `a` contains `needle`, and the index of `needle`.\n    /// `index` precedence: equal to > nearest before > nearest after.\n    function searchSorted(uint256[] memory a, uint256 needle)\n        internal\n        pure\n        returns (bool found, uint256 index)\n    {\n        (found, index) = _searchSorted(a, needle, 0);\n    }\n\n    /// @dev Returns whether `a` contains `needle`, and the index of `needle`.\n    /// `index` precedence: equal to > nearest before > nearest after.\n    function searchSorted(int256[] memory a, int256 needle)\n        internal\n        pure\n        returns (bool found, uint256 index)\n    {\n        (found, index) = _searchSorted(_toUints(a), uint256(needle), 1 << 255);\n    }\n\n    /// @dev Returns whether `a` contains `needle`, and the index of `needle`.\n    /// `index` precedence: equal to > nearest before > nearest after.\n    function searchSorted(address[] memory a, address needle)\n        internal\n        pure\n        returns (bool found, uint256 index)\n    {\n        (found, index) = _searchSorted(_toUints(a), uint256(uint160(needle)), 0);\n    }\n\n    /// @dev Reverses the array in-place.\n    function reverse(uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(mload(a), 2)) {\n                let s := 0x20\n                let w := not(0x1f)\n                let h := add(a, shl(5, mload(a)))\n                for { a := add(a, s) } 1 {} {\n                    let t := mload(a)\n                    mstore(a, mload(h))\n                    mstore(h, t)\n                    h := add(h, w)\n                    a := add(a, s)\n                    if iszero(lt(a, h)) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Reverses the array in-place.\n    function reverse(int256[] memory a) internal pure {\n        reverse(_toUints(a));\n    }\n\n    /// @dev Reverses the array in-place.\n    function reverse(address[] memory a) internal pure {\n        reverse(_toUints(a));\n    }\n\n    /// @dev Returns a copy of the array.\n    function copy(uint256[] memory a) internal pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let end := add(add(result, 0x20), shl(5, mload(a)))\n            let o := result\n            for { let d := sub(a, result) } 1 {} {\n                mstore(o, mload(add(o, d)))\n                o := add(0x20, o)\n                if eq(o, end) { break }\n            }\n            mstore(0x40, o)\n        }\n    }\n\n    /// @dev Returns a copy of the array.\n    function copy(int256[] memory a) internal pure returns (int256[] memory result) {\n        result = _toInts(copy(_toUints(a)));\n    }\n\n    /// @dev Returns a copy of the array.\n    function copy(address[] memory a) internal pure returns (address[] memory result) {\n        result = _toAddresses(copy(_toUints(a)));\n    }\n\n    /// @dev Returns whether the array is sorted in ascending order.\n    function isSorted(uint256[] memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if iszero(lt(mload(a), 2)) {\n                let end := add(a, shl(5, mload(a)))\n                for { a := add(a, 0x20) } 1 {} {\n                    let p := mload(a)\n                    a := add(a, 0x20)\n                    result := iszero(gt(p, mload(a)))\n                    if iszero(mul(result, xor(a, end))) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns whether the array is sorted in ascending order.\n    function isSorted(int256[] memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if iszero(lt(mload(a), 2)) {\n                let end := add(a, shl(5, mload(a)))\n                for { a := add(a, 0x20) } 1 {} {\n                    let p := mload(a)\n                    a := add(a, 0x20)\n                    result := iszero(sgt(p, mload(a)))\n                    if iszero(mul(result, xor(a, end))) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns whether the array is sorted in ascending order.\n    function isSorted(address[] memory a) internal pure returns (bool result) {\n        result = isSorted(_toUints(a));\n    }\n\n    /// @dev Returns whether the array is strictly ascending (sorted and uniquified).\n    function isSortedAndUniquified(uint256[] memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if iszero(lt(mload(a), 2)) {\n                let end := add(a, shl(5, mload(a)))\n                for { a := add(a, 0x20) } 1 {} {\n                    let p := mload(a)\n                    a := add(a, 0x20)\n                    result := lt(p, mload(a))\n                    if iszero(mul(result, xor(a, end))) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns whether the array is strictly ascending (sorted and uniquified).\n    function isSortedAndUniquified(int256[] memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if iszero(lt(mload(a), 2)) {\n                let end := add(a, shl(5, mload(a)))\n                for { a := add(a, 0x20) } 1 {} {\n                    let p := mload(a)\n                    a := add(a, 0x20)\n                    result := slt(p, mload(a))\n                    if iszero(mul(result, xor(a, end))) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns whether the array is strictly ascending (sorted and uniquified).\n    function isSortedAndUniquified(address[] memory a) internal pure returns (bool result) {\n        result = isSortedAndUniquified(_toUints(a));\n    }\n\n    /// @dev Returns the sorted set difference of `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function difference(uint256[] memory a, uint256[] memory b)\n        internal\n        pure\n        returns (uint256[] memory c)\n    {\n        c = _difference(a, b, 0);\n    }\n\n    /// @dev Returns the sorted set difference between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function difference(int256[] memory a, int256[] memory b)\n        internal\n        pure\n        returns (int256[] memory c)\n    {\n        c = _toInts(_difference(_toUints(a), _toUints(b), 1 << 255));\n    }\n\n    /// @dev Returns the sorted set difference between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function difference(address[] memory a, address[] memory b)\n        internal\n        pure\n        returns (address[] memory c)\n    {\n        c = _toAddresses(_difference(_toUints(a), _toUints(b), 0));\n    }\n\n    /// @dev Returns the sorted set intersection between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function intersection(uint256[] memory a, uint256[] memory b)\n        internal\n        pure\n        returns (uint256[] memory c)\n    {\n        c = _intersection(a, b, 0);\n    }\n\n    /// @dev Returns the sorted set intersection between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function intersection(int256[] memory a, int256[] memory b)\n        internal\n        pure\n        returns (int256[] memory c)\n    {\n        c = _toInts(_intersection(_toUints(a), _toUints(b), 1 << 255));\n    }\n\n    /// @dev Returns the sorted set intersection between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function intersection(address[] memory a, address[] memory b)\n        internal\n        pure\n        returns (address[] memory c)\n    {\n        c = _toAddresses(_intersection(_toUints(a), _toUints(b), 0));\n    }\n\n    /// @dev Returns the sorted set union of `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function union(uint256[] memory a, uint256[] memory b)\n        internal\n        pure\n        returns (uint256[] memory c)\n    {\n        c = _union(a, b, 0);\n    }\n\n    /// @dev Returns the sorted set union of `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function union(int256[] memory a, int256[] memory b)\n        internal\n        pure\n        returns (int256[] memory c)\n    {\n        c = _toInts(_union(_toUints(a), _toUints(b), 1 << 255));\n    }\n\n    /// @dev Returns the sorted set union between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function union(address[] memory a, address[] memory b)\n        internal\n        pure\n        returns (address[] memory c)\n    {\n        c = _toAddresses(_union(_toUints(a), _toUints(b), 0));\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Reinterpret cast to an uint256 array.\n    function _toUints(int256[] memory a) private pure returns (uint256[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }\n\n    /// @dev Reinterpret cast to an uint256 array.\n    function _toUints(address[] memory a) private pure returns (uint256[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // As any address written to memory will have the upper 96 bits\n            // of the word zeroized (as per Solidity spec), we can directly\n            // compare these addresses as if they are whole uint256 words.\n            casted := a\n        }\n    }\n\n    /// @dev Reinterpret cast to an int array.\n    function _toInts(uint256[] memory a) private pure returns (int256[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }\n\n    /// @dev Reinterpret cast to an address array.\n    function _toAddresses(uint256[] memory a) private pure returns (address[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }\n\n    /// @dev Converts an array of signed integers to unsigned\n    /// integers suitable for sorting or vice versa.\n    function _flipSign(int256[] memory a) private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := shl(255, 1)\n            for { let end := add(a, shl(5, mload(a))) } iszero(eq(a, end)) {} {\n                a := add(a, 0x20)\n                mstore(a, add(mload(a), w))\n            }\n        }\n    }\n\n    /// @dev Returns whether `a` contains `needle`, and the index of `needle`.\n    /// `index` precedence: equal to > nearest before > nearest after.\n    function _searchSorted(uint256[] memory a, uint256 needle, uint256 signed)\n        private\n        pure\n        returns (bool found, uint256 index)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0)\n            let l := 1\n            let h := mload(a)\n            let t := 0\n            for { needle := add(signed, needle) } 1 {} {\n                index := shr(1, add(l, h))\n                t := add(signed, mload(add(a, shl(5, index))))\n                if or(gt(l, h), eq(t, needle)) { break }\n                // Decide whether to search the left or right half.\n                if iszero(gt(needle, t)) {\n                    h := add(index, w)\n                    continue\n                }\n                l := add(index, 1)\n            }\n            // `index` will be zero in the case of an empty array,\n            // or when the value is less than the smallest value in the array.\n            found := eq(t, needle)\n            t := iszero(iszero(index))\n            index := mul(add(index, w), t)\n            found := and(found, t)\n        }\n    }\n\n    /// @dev Returns the sorted set difference of `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function _difference(uint256[] memory a, uint256[] memory b, uint256 signed)\n        private\n        pure\n        returns (uint256[] memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := 0x20\n            let aEnd := add(a, shl(5, mload(a)))\n            let bEnd := add(b, shl(5, mload(b)))\n            c := mload(0x40) // Set `c` to the free memory pointer.\n            a := add(a, s)\n            b := add(b, s)\n            let k := c\n            for {} iszero(or(gt(a, aEnd), gt(b, bEnd))) {} {\n                let u := mload(a)\n                let v := mload(b)\n                if iszero(xor(u, v)) {\n                    a := add(a, s)\n                    b := add(b, s)\n                    continue\n                }\n                if iszero(lt(add(u, signed), add(v, signed))) {\n                    b := add(b, s)\n                    continue\n                }\n                k := add(k, s)\n                mstore(k, u)\n                a := add(a, s)\n            }\n            for {} iszero(gt(a, aEnd)) {} {\n                k := add(k, s)\n                mstore(k, mload(a))\n                a := add(a, s)\n            }\n            mstore(c, shr(5, sub(k, c))) // Store the length of `c`.\n            mstore(0x40, add(k, s)) // Allocate the memory for `c`.\n        }\n    }\n\n    /// @dev Returns the sorted set intersection between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function _intersection(uint256[] memory a, uint256[] memory b, uint256 signed)\n        private\n        pure\n        returns (uint256[] memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := 0x20\n            let aEnd := add(a, shl(5, mload(a)))\n            let bEnd := add(b, shl(5, mload(b)))\n            c := mload(0x40) // Set `c` to the free memory pointer.\n            a := add(a, s)\n            b := add(b, s)\n            let k := c\n            for {} iszero(or(gt(a, aEnd), gt(b, bEnd))) {} {\n                let u := mload(a)\n                let v := mload(b)\n                if iszero(xor(u, v)) {\n                    k := add(k, s)\n                    mstore(k, u)\n                    a := add(a, s)\n                    b := add(b, s)\n                    continue\n                }\n                if iszero(lt(add(u, signed), add(v, signed))) {\n                    b := add(b, s)\n                    continue\n                }\n                a := add(a, s)\n            }\n            mstore(c, shr(5, sub(k, c))) // Store the length of `c`.\n            mstore(0x40, add(k, s)) // Allocate the memory for `c`.\n        }\n    }\n\n    /// @dev Returns the sorted set union of `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function _union(uint256[] memory a, uint256[] memory b, uint256 signed)\n        private\n        pure\n        returns (uint256[] memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := 0x20\n            let aEnd := add(a, shl(5, mload(a)))\n            let bEnd := add(b, shl(5, mload(b)))\n            c := mload(0x40) // Set `c` to the free memory pointer.\n            a := add(a, s)\n            b := add(b, s)\n            let k := c\n            for {} iszero(or(gt(a, aEnd), gt(b, bEnd))) {} {\n                let u := mload(a)\n                let v := mload(b)\n                if iszero(xor(u, v)) {\n                    k := add(k, s)\n                    mstore(k, u)\n                    a := add(a, s)\n                    b := add(b, s)\n                    continue\n                }\n                if iszero(lt(add(u, signed), add(v, signed))) {\n                    k := add(k, s)\n                    mstore(k, v)\n                    b := add(b, s)\n                    continue\n                }\n                k := add(k, s)\n                mstore(k, u)\n                a := add(a, s)\n            }\n            for {} iszero(gt(a, aEnd)) {} {\n                k := add(k, s)\n                mstore(k, mload(a))\n                a := add(a, s)\n            }\n            for {} iszero(gt(b, bEnd)) {} {\n                k := add(k, s)\n                mstore(k, mload(b))\n                b := add(b, s)\n            }\n            mstore(c, shr(5, sub(k, c))) // Store the length of `c`.\n            mstore(0x40, add(k, s)) // Allocate the memory for `c`.\n        }\n    }\n}\n"}},"settings":{"remappings":["@openzeppelin/=node_modules/@openzeppelin/","solmate/=node_modules/solmate/src/","solady/=node_modules/solady/src/","forge-std/=node_modules/forge-std/src/","ds-test/=node_modules/ds-test/src/","erc4337-validation/=node_modules/@rhinestone/erc4337-validation/src/","account-abstraction/=node_modules/account-abstraction/contracts/","account-abstraction-v0.6/=node_modules/account-abstraction-v0.6/contracts/","safe-singleton-deployer/=node_modules/safe-singleton-deployer/src/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"]}},"evmVersion":"cancun","viaIR":false,"libraries":{}}}
